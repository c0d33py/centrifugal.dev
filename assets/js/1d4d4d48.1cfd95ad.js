"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[9727],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=s(n),m=r,k=c["".concat(p,".").concat(m)]||c[m]||u[m]||l;return n?a.createElement(k,o(o({ref:t},d),{},{components:n})):a.createElement(k,o({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=c;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var s=2;s<l;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},3452:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const l={id:"proxy",title:"Proxy to backend"},o=void 0,i={unversionedId:"server/proxy",id:"version-3/server/proxy",title:"Proxy to backend",description:"It's possible to proxy some client connection events from Centrifugo to the application backend and react to them in a custom way. For example, it's possible to authenticate connection via request from Centrifugo to application backend, refresh client sessions and answer to RPC calls sent by a client over bidirectional connection.",source:"@site/versioned_docs/version-3/server/proxy.md",sourceDirName:"server",slug:"/server/proxy",permalink:"/docs/3/server/proxy",draft:!1,editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/versioned_docs/version-3/server/proxy.md",tags:[],version:"3",frontMatter:{id:"proxy",title:"Proxy to backend"},sidebar:"Guides",previous:{title:"Engines, scalability",permalink:"/docs/3/server/engines"},next:{title:"History and recovery",permalink:"/docs/3/server/history_and_recovery"}},p={},s=[{value:"HTTP proxy",id:"http-proxy",level:2},{value:"HTTP request structure",id:"http-request-structure",level:3},{value:"Proxy HTTP headers",id:"proxy-http-headers",level:3},{value:"Proxy GRPC metadata",id:"proxy-grpc-metadata",level:3},{value:"Connect proxy",id:"connect-proxy",level:3},{value:"Connect request fields",id:"connect-request-fields",level:4},{value:"Connect result fields",id:"connect-result-fields",level:4},{value:"Options",id:"options",level:4},{value:"Example",id:"example",level:4},{value:"Refresh proxy",id:"refresh-proxy",level:3},{value:"Refresh request fields",id:"refresh-request-fields",level:4},{value:"Refresh result fields",id:"refresh-result-fields",level:4},{value:"Options",id:"options-1",level:4},{value:"RPC proxy",id:"rpc-proxy",level:3},{value:"RPC request fields",id:"rpc-request-fields",level:4},{value:"RPC result fields",id:"rpc-result-fields",level:4},{value:"Options",id:"options-2",level:4},{value:"Subscribe proxy",id:"subscribe-proxy",level:3},{value:"Subscribe request fields",id:"subscribe-request-fields",level:4},{value:"Subscribe result fields",id:"subscribe-result-fields",level:4},{value:"Override object",id:"override-object",level:4},{value:"Options",id:"options-3",level:4},{value:"Publish proxy",id:"publish-proxy",level:3},{value:"Publish request fields",id:"publish-request-fields",level:4},{value:"Publish result fields",id:"publish-result-fields",level:4},{value:"Options",id:"options-4",level:4},{value:"Return custom error",id:"return-custom-error",level:3},{value:"Return custom disconnect",id:"return-custom-disconnect",level:3},{value:"GRPC proxy",id:"grpc-proxy",level:2},{value:"GRPC proxy options",id:"grpc-proxy-options",level:3},{value:"proxy_grpc_cert_file",id:"proxy_grpc_cert_file",level:4},{value:"proxy_grpc_credentials_key",id:"proxy_grpc_credentials_key",level:4},{value:"proxy_grpc_credentials_value",id:"proxy_grpc_credentials_value",level:4},{value:"GRPC proxy example",id:"grpc-proxy-example",level:3},{value:"Header proxy rules",id:"header-proxy-rules",level:2},{value:"Binary mode",id:"binary-mode",level:2},{value:"Granular proxy mode",id:"granular-proxy-mode",level:2},{value:"Enable granular proxy mode",id:"enable-granular-proxy-mode",level:3},{value:"Defining a list of proxies",id:"defining-a-list-of-proxies",level:3},{value:"Granular connect and refresh",id:"granular-connect-and-refresh",level:3},{value:"Granular subscribe and publish",id:"granular-subscribe-and-publish",level:3},{value:"Granular RPC",id:"granular-rpc",level:3}],d={toc:s};function u(e){let{components:t,...l}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"It's possible to proxy some client connection events from Centrifugo to the application backend and react to them in a custom way. For example, it's possible to authenticate connection via request from Centrifugo to application backend, refresh client sessions and answer to RPC calls sent by a client over bidirectional connection."),(0,r.kt)("p",null,"The list of events that can be proxied:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Connect \u2013 called when a client connects to Centrifugo, so it's possible to authenticate user, return custom data to a client, subscribe connection to several channels, attach meta information to the connection, and so on. Works for bidirectional and unidirectional transports."),(0,r.kt)("li",{parentName:"ul"},"Refresh - called when a client session is going to expire, so it's possible to prolong it or just let it expire. Can also be used just as a periodical connection liveness callback from Centrifugo to app backend. Works for bidirectional and unidirectional transports."),(0,r.kt)("li",{parentName:"ul"},"Subscribe - called when clients try to subscribe on a channel, so it's possible to check permissions and return custom initial subscription data. Works for bidirectional transports only."),(0,r.kt)("li",{parentName:"ul"},"Publish - called when a client tries to publish into a channel, so it's possible to check permissions and optionally modify publication data. Works for bidirectional transports only."),(0,r.kt)("li",{parentName:"ul"},"RPC - called when a client sends RPC, you can do whatever logic you need based on a client-provided RPC method and params. Works for bidirectional transports only.")),(0,r.kt)("p",null,"At the moment Centrifugo can proxy these events over two protocols:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"HTTP (JSON payloads)"),(0,r.kt)("li",{parentName:"ul"},"GRPC (Protobuf messages)")),(0,r.kt)("h2",{id:"http-proxy"},"HTTP proxy"),(0,r.kt)("p",null,"HTTP proxy in Centrifugo converts client connection events into HTTP call to the application backend."),(0,r.kt)("h3",{id:"http-request-structure"},"HTTP request structure"),(0,r.kt)("p",null,"All proxy calls are ",(0,r.kt)("strong",{parentName:"p"},"HTTP POST")," requests that will be sent from Centrifugo to configured endpoints with a configured timeout. These requests will have some headers copied from the original client request (see details below) and include JSON body which varies depending on call type (for example data sent by a client in RPC call etc, see more details about JSON bodies below)."),(0,r.kt)("h3",{id:"proxy-http-headers"},"Proxy HTTP headers"),(0,r.kt)("p",null,"The good thing about Centrifugo HTTP proxy is that it transparently proxies original HTTP request headers in a request to app backend. In most cases this allows achieving transparent authentication on the application backend side. But it's required to provide an explicit list of HTTP headers you want to be proxied, for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="config.json"',title:'"config.json"'},'{\n    ...\n    "proxy_http_headers": [\n        "Origin",\n        "User-Agent",\n        "Cookie",\n        "Authorization",\n        "X-Real-Ip",\n        "X-Forwarded-For",\n        "X-Request-Id"\n    ]\n}\n')),(0,r.kt)("p",null,"Alternatively, you can set a list of headers via an environment variable (space separated):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'export CENTRIFUGO_PROXY_HTTP_HEADERS="Cookie User-Agent X-B3-TraceId X-B3-SpanId" ./centrifugo\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Centrifugo forces the",(0,r.kt)("inlineCode",{parentName:"p"}," Content-Type")," header to be ",(0,r.kt)("inlineCode",{parentName:"p"},"application/json")," in all HTTP proxy requests since it sends the body in JSON format to the application backend.")),(0,r.kt)("h3",{id:"proxy-grpc-metadata"},"Proxy GRPC metadata"),(0,r.kt)("p",null,"When ",(0,r.kt)("a",{parentName:"p",href:"/docs/3/transports/uni_grpc"},"GRPC unidirectional stream")," is used as a client transport then you may want to proxy GRPC metadata from the client request. In this case you may configure ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy_grpc_metadata")," option. This is an array of string metadata keys which will be proxied. These metadata keys transformed to HTTP headers of proxy request. By default no metadata keys are proxied."),(0,r.kt)("p",null,"See below ",(0,r.kt)("a",{parentName:"p",href:"#header-proxy-rules"},"the table of rules")," how metadata and headers proxied in transport/proxy different scenarios. "),(0,r.kt)("h3",{id:"connect-proxy"},"Connect proxy"),(0,r.kt)("p",null,"With the following options in the configuration file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  ...\n  "proxy_connect_endpoint": "http://localhost:3000/centrifugo/connect",\n  "proxy_connect_timeout":  "1s"\n}\n')),(0,r.kt)("p",null,"\u2013 connection requests ",(0,r.kt)("strong",{parentName:"p"},"without JWT set")," will be proxied to ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy_connect_endpoint")," URL endpoint. On your backend side, you can authenticate the incoming connection and return client credentials to Centrifugo in response to the proxied request."),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"Make sure you properly configured ",(0,r.kt)("a",{parentName:"p",href:"/docs/3/server/configuration#allowed_origins"},"allowed_origins")," Centrifugo option or check request origin on your backend side upon receiving connect request from Centrifugo. Otherwise, your site can be vulnerable to CSRF attacks if you are using WebSocket transport for client connections.")),(0,r.kt)("p",null,"Yes, this means you don't need to generate JWT and pass it to a client-side and can rely on a cookie while authenticating the user. ",(0,r.kt)("strong",{parentName:"p"},"Centrifugo should work on the same domain in this case so your site cookie could be passed to Centrifugo by browsers"),"."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"If you want to pass some custom authentication token from a client side (not in Centrifugo JWT format) but force request to be proxied then you may put it in a cookie or use connection request custom ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," field (available in all our transports). This ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," can contain arbitrary payload you want to pass from a client to a server.")),(0,r.kt)("p",null,"This also means that ",(0,r.kt)("strong",{parentName:"p"},"every")," new connection from a user will result in an HTTP POST request to your application backend. While with JWT token you usually generate it once on application page reload, if client reconnects due to Centrifugo restart or internet connection loss it uses the same JWT it had before thus usually no additional requests are generated during reconnect process (until JWT expired)."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(330).Z,width:"2600",height:"1032"})),(0,r.kt)("p",null,"Payload example that will be sent to app backend when client without token wants to establish a connection with Centrifugo and ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy_connect_endpoint")," is set to non-empty URL string:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "client":"9336a229-2400-4ebc-8c50-0a643d22e8a0",\n  "transport":"websocket",\n  "protocol": "json",\n  "encoding":"json"\n}\n')),(0,r.kt)("p",null,"Expected response example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"result": {"user": "56"}}\n')),(0,r.kt)("p",null,"This response allows connecting and tells Centrifugo the ID of a user. See below the full list of supported fields in the result."),(0,r.kt)("p",null,"Several app examples which use connect proxy can be found in our blog:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/blog/2021/10/18/integrating-with-nodejs"},"With NodeJS")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/blog/2021/11/04/integrating-with-django-building-chat-application"},"With Django")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/blog/2021/12/14/laravel-multi-room-chat-tutorial"},"With Laravel"))),(0,r.kt)("h4",{id:"connect-request-fields"},"Connect request fields"),(0,r.kt)("p",null,"This is what sent from Centrifugo to application backend in case of connect proxy request."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Optional"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"client"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"unique client ID generated by Centrifugo for each incoming connection")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"transport"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"transport name (ex. ",(0,r.kt)("inlineCode",{parentName:"td"},"websocket"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"sockjs"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"uni_sse")," etc)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"protocol"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"protocol type used by the client (",(0,r.kt)("inlineCode",{parentName:"td"},"json")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"protobuf")," at moment)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"encoding"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"protocol encoding type used (",(0,r.kt)("inlineCode",{parentName:"td"},"json")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"binary")," at moment)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"name"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"optional name of the client (this field will only be set if provided by a client on connect)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"version"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"optional version of the client (this field will only be set if provided by a client on connect)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"data"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"optional data from client (this field will only be set if provided by a client on connect)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"b64data"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"optional data from the client in base64 format (if the binary proxy mode is used)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"channels"),(0,r.kt)("td",{parentName:"tr",align:null},"Array of strings"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"list of server-side channels client want to subscribe to, the application server must check permissions and add allowed channels to result")))),(0,r.kt)("h4",{id:"connect-result-fields"},"Connect result fields"),(0,r.kt)("p",null,"This is what application returns to Centrifugo inside ",(0,r.kt)("inlineCode",{parentName:"p"},"result")," field in case of connect proxy request."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Optional"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"user"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"user ID (calculated on app backend based on request cookie header for example). Return it as an empty string for accepting unauthenticated requests")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expire_at"),(0,r.kt)("td",{parentName:"tr",align:null},"integer"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a timestamp when connection must be considered expired. If not set or set to ",(0,r.kt)("inlineCode",{parentName:"td"},"0")," connection won't expire at all")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"info"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a connection info JSON")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"b64info"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"binary connection info encoded in base64 format, will be decoded to raw bytes on Centrifugo before using in messages")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"data"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a custom data to send to the client in connect command response.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"b64data"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a custom data to send to the client in the connect command response for binary connections, will be decoded to raw bytes on Centrifugo side before sending to client")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"channels"),(0,r.kt)("td",{parentName:"tr",align:null},"array of strings"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"allows providing a list of server-side channels to subscribe connection to. See more details about ",(0,r.kt)("a",{parentName:"td",href:"/docs/3/server/server_subs"},"server-side subscriptions"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subs"),(0,r.kt)("td",{parentName:"tr",align:null},"map of SubscribeOptions"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"map of channels with options to subscribe connection to. See more details about ",(0,r.kt)("a",{parentName:"td",href:"/docs/3/server/server_subs"},"server-side subscriptions"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"meta"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON object (ex. ",(0,r.kt)("inlineCode",{parentName:"td"},'{"key": "value"}'),")"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a custom data to attach to connection (this ",(0,r.kt)("strong",{parentName:"td"},"won't be exposed to client-side"),")")))),(0,r.kt)("h4",{id:"options"},"Options"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"proxy_connect_timeout")," (float, in seconds) config option controls timeout of HTTP POST request sent to app backend."),(0,r.kt)("h4",{id:"example"},"Example"),(0,r.kt)("p",null,"Here is the simplest example of the connect handler in Tornado Python framework (note that in a real system you need to authenticate the user on your backend side, here we just return ",(0,r.kt)("inlineCode",{parentName:"p"},'"56"')," as user ID):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class CentrifugoConnectHandler(tornado.web.RequestHandler):\n\n    def check_xsrf_cookie(self):\n        pass\n\n    def post(self):\n        self.set_header('Content-Type', 'application/json; charset=\"utf-8\"')\n        data = json.dumps({\n            'result': {\n                'user': '56'\n            }\n        })\n        self.write(data)\n\n\ndef main():\n    options.parse_command_line()\n    app = tornado.web.Application([\n      (r'/centrifugo/connect', CentrifugoConnectHandler),\n    ])\n    app.listen(3000)\n    tornado.ioloop.IOLoop.instance().start()\n\n\nif __name__ == '__main__':\n    main()\n")),(0,r.kt)("p",null,"This example should help you to implement a similar HTTP handler in any language/framework you are using on the backend side."),(0,r.kt)("p",null,"We also have a tutorial in the blog about ",(0,r.kt)("a",{parentName:"p",href:"/blog/2021/10/18/integrating-with-nodejs"},"Centrifugo integration with NodeJS")," which uses connect proxy and native session middleware of Express.js to authenticate connections. Even if you are not using NodeJS on a backend a tutorial can help you understand the idea."),(0,r.kt)("h3",{id:"refresh-proxy"},"Refresh proxy"),(0,r.kt)("p",null,"With the following options in the configuration file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  ...\n  "proxy_refresh_endpoint": "http://localhost:3000/centrifugo/refresh",\n  "proxy_refresh_timeout":  "1s"\n}\n')),(0,r.kt)("p",null,"\u2013 Centrifugo will call ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy_refresh_endpoint")," when it's time to refresh the connection. Centrifugo itself will ask your backend about connection validity instead of refresh workflow on the client-side."),(0,r.kt)("p",null,"The payload sent to app backend in refresh request (when the connection is going to expire):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "client":"9336a229-2400-4ebc-8c50-0a643d22e8a0",\n  "transport":"websocket",\n  "protocol": "json",\n  "encoding":"json",\n  "user":"56"\n}\n')),(0,r.kt)("p",null,"Expected response example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"result": {"expire_at": 1565436268}}\n')),(0,r.kt)("h4",{id:"refresh-request-fields"},"Refresh request fields"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Optional"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"client"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"unique client ID generated by Centrifugo for each incoming connection")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"transport"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"transport name (ex. ",(0,r.kt)("inlineCode",{parentName:"td"},"websocket"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"sockjs"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"uni_sse")," etc.)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"protocol"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"protocol type used by client (",(0,r.kt)("inlineCode",{parentName:"td"},"json")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"protobuf")," at moment)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"encoding"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"protocol encoding type used (",(0,r.kt)("inlineCode",{parentName:"td"},"json")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"binary")," at moment)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"user"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"a connection user ID obtained during authentication process")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"meta"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a connection attached meta (off by default, enable with ",(0,r.kt)("inlineCode",{parentName:"td"},'"proxy_include_connection_meta": true'),")")))),(0,r.kt)("h4",{id:"refresh-result-fields"},"Refresh result fields"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Optional"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expired"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a flag to mark the connection as expired - the client will be disconnected")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expire_at"),(0,r.kt)("td",{parentName:"tr",align:null},"integer"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a timestamp in the future when connection must be considered expired")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"info"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a connection info JSON")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"b64info"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"binary connection info encoded in base64 format, will be decoded to raw bytes on Centrifugo before using in messages")))),(0,r.kt)("h4",{id:"options-1"},"Options"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"proxy_refresh_timeout")," (float, in seconds) config option controls timeout of HTTP POST request sent to app backend."),(0,r.kt)("h3",{id:"rpc-proxy"},"RPC proxy"),(0,r.kt)("p",null,"With the following option in the configuration file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  ...\n  "proxy_rpc_endpoint": "http://localhost:3000/centrifugo/connect",\n  "proxy_rpc_timeout":  "1s"\n}\n')),(0,r.kt)("p",null,"RPC calls over client connection will be proxied to ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy_rpc_endpoint"),". This allows a developer to utilize WebSocket (or SockJS) connection in a bidirectional way."),(0,r.kt)("p",null,"Payload example sent to app backend in RPC request:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "client":"9336a229-2400-4ebc-8c50-0a643d22e8a0",\n  "transport":"websocket",\n  "protocol": "json",\n  "encoding":"json",\n  "user":"56",\n  "method": "getCurrentPrice",\n  "data":{"params": {"object_id": 12}}\n}\n')),(0,r.kt)("p",null,"Expected response example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"result": {"data": {"answer": "2019"}}}\n')),(0,r.kt)("h4",{id:"rpc-request-fields"},"RPC request fields"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Optional"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"client"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"unique client ID generated by Centrifugo for each incoming connection")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"transport"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"transport name (ex. ",(0,r.kt)("inlineCode",{parentName:"td"},"websocket")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"sockjs"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"protocol"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"protocol type used by the client (",(0,r.kt)("inlineCode",{parentName:"td"},"json")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"protobuf")," at moment)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"encoding"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"protocol encoding type used (",(0,r.kt)("inlineCode",{parentName:"td"},"json")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"binary")," at moment)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"user"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"a connection user ID obtained during authentication process")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"method"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"an RPC method string, if the client does not use named RPC call then method will be omitted")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"data"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"RPC custom data sent by client")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"b64data"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"will be set instead of ",(0,r.kt)("inlineCode",{parentName:"td"},"data")," field for binary proxy mode")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"meta"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a connection attached meta (off by default, enable with ",(0,r.kt)("inlineCode",{parentName:"td"},'"proxy_include_connection_meta": true'),")")))),(0,r.kt)("h4",{id:"rpc-result-fields"},"RPC result fields"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Optional"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"data"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"RPC response - any valid JSON is supported")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"b64data"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"can be set instead of ",(0,r.kt)("inlineCode",{parentName:"td"},"data")," for binary response encoded in base64 format")))),(0,r.kt)("h4",{id:"options-2"},"Options"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"proxy_rpc_timeout")," (float, in seconds) config option controls timeout of HTTP POST request sent to app backend."),(0,r.kt)("p",null,"See below on how to return a custom error."),(0,r.kt)("h3",{id:"subscribe-proxy"},"Subscribe proxy"),(0,r.kt)("p",null,"With the following option in the configuration file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  ...\n  "proxy_subscribe_endpoint": "http://localhost:3000/centrifugo/subscribe",\n  "proxy_subscribe_timeout":  "1s"\n}\n')),(0,r.kt)("p",null,"\u2013 subscribe requests sent over client connection will be proxied to ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy_subscribe_endpoint"),". This allows you to check the access of the client to a channel."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Subscribe proxy does not proxy ",(0,r.kt)("a",{parentName:"strong",href:"/docs/3/server/channels#private-channel-prefix"},"private")," and ",(0,r.kt)("a",{parentName:"strong",href:"/docs/3/server/channels#user-channel-boundary"},"user-limited")," channels at the moment"),". That's because those are already providing a level of security (user-limited channels check current user ID, private channels require subscription token). In some cases you may use subscribe proxy as a replacement for private channels actually: if you prefer to check permissions using the proxy to backend mechanism \u2013 just stop using ",(0,r.kt)("inlineCode",{parentName:"p"},"$")," prefixes in channels, properly configure subscribe proxy and validate subscriptions upon proxy from Centrifugo to your backend (issued each time user tries to subscribe on a channel for which subscribe proxy enabled).")),(0,r.kt)("p",null,"Unlike proxy types described above subscribe proxy must be enabled per channel namespace. This means that every namespace (including global/default one) has a boolean option ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy_subscribe")," that enables subscribe proxy for channels in a namespace."),(0,r.kt)("p",null,"So to enable subscribe proxy for channels without namespace define ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy_subscribe")," on a top configuration level:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  ...\n  "proxy_subscribe_endpoint": "http://localhost:3000/centrifugo/subscribe",\n  "proxy_subscribe_timeout":  "1s",\n  "proxy_subscribe": true\n}\n')),(0,r.kt)("p",null,"Or for channels in namespace ",(0,r.kt)("inlineCode",{parentName:"p"},"sun"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  ...\n  "proxy_subscribe_endpoint": "http://localhost:3000/centrifugo/subscribe",\n  "proxy_subscribe_timeout":  "1s",\n  "namespaces": [{\n    "name": "sun",\n    "proxy_subscribe": true\n  }]\n}\n')),(0,r.kt)("p",null,"Payload example sent to app backend in subscribe request:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "client":"9336a229-2400-4ebc-8c50-0a643d22e8a0",\n  "transport":"websocket",\n  "protocol": "json",\n  "encoding":"json",\n  "user":"56",\n  "channel": "chat:index"\n}\n')),(0,r.kt)("p",null,"Expected response example if subscription is allowed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"result": {}}\n')),(0,r.kt)("h4",{id:"subscribe-request-fields"},"Subscribe request fields"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Optional"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"client"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"unique client ID generated by Centrifugo for each incoming connection")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"transport"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"transport name (ex. ",(0,r.kt)("inlineCode",{parentName:"td"},"websocket")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"sockjs"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"protocol"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"protocol type used by the client (",(0,r.kt)("inlineCode",{parentName:"td"},"json")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"protobuf")," at moment)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"encoding"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"protocol encoding type used (",(0,r.kt)("inlineCode",{parentName:"td"},"json")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"binary")," at moment)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"user"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"a connection user ID obtained during authentication process")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"channel"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"a string channel client wants to subscribe to")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"meta"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a connection attached meta (off by default, enable with ",(0,r.kt)("inlineCode",{parentName:"td"},'"proxy_include_connection_meta": true'),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"data"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"custom data from client sent with subscription request (this field will only be set if provided by a client on subscribe). Available since Centrifugo v3.1.1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"b64data"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"optional subscription data from the client in base64 format (if the binary proxy mode is used). Available since Centrifugo v3.1.1")))),(0,r.kt)("h4",{id:"subscribe-result-fields"},"Subscribe result fields"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Optional"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"info"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a channel info JSON")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"b64info"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a binary connection channel info encoded in base64 format, will be decoded to raw bytes on Centrifugo before using")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"data"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a custom data to send to the client in subscribe command reply.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"b64data"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a custom data to send to the client in subscribe command reply, will be decoded to raw bytes on Centrifugo side before sending to client")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"override"),(0,r.kt)("td",{parentName:"tr",align:null},"Override object"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Allows dynamically override some channel options defined in Centrifugo configuration on a per-connection basis (see below available fields)")))),(0,r.kt)("h4",{id:"override-object"},"Override object"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Optional"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"presence"),(0,r.kt)("td",{parentName:"tr",align:null},"BoolValue"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Override presence")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"join_leave"),(0,r.kt)("td",{parentName:"tr",align:null},"BoolValue"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Override join_leave")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"position"),(0,r.kt)("td",{parentName:"tr",align:null},"BoolValue"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Override position")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"recover"),(0,r.kt)("td",{parentName:"tr",align:null},"BoolValue"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Override recover")))),(0,r.kt)("p",null,"BoolValue is an object like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "value": true/false\n}\n')),(0,r.kt)("p",null,"See below on how to return an error in case you don't want to allow subscribing."),(0,r.kt)("h4",{id:"options-3"},"Options"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"proxy_subscribe_timeout")," (float, in seconds) config option controls timeout of HTTP POST request sent to app backend."),(0,r.kt)("h3",{id:"publish-proxy"},"Publish proxy"),(0,r.kt)("p",null,"With the following option in the configuration file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  ...\n  "proxy_publish_endpoint": "http://localhost:3000/centrifugo/publish",\n  "proxy_publish_timeout":  "1s"\n}\n')),(0,r.kt)("p",null,"\u2013 publish calls sent by a client will be proxied to ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy_publish_endpoint"),"."),(0,r.kt)("p",null,"This request happens BEFORE a message is published to a channel, so your backend can validate whether a client can publish data to a channel. An important thing here is that publication to the channel can fail after your backend successfully validated publish request (for example publish to Redis by Centrifugo returned an error). In this case, your backend won't know about the error that happened but this error will propagate to the client-side. "),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(8719).Z,width:"2600",height:"1098"})),(0,r.kt)("p",null,"Like the subscribe proxy, publish proxy must be enabled per channel namespace. This means that every namespace (including the global/default one) has a boolean option ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy_publish")," that enables publish proxy for channels in the namespace. All other namespace options will be taken into account before making a proxy request, so you also need to turn on the ",(0,r.kt)("inlineCode",{parentName:"p"},"publish")," option too."),(0,r.kt)("p",null,"So to enable publish proxy for channels without namespace define ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy_publish")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"publish")," on a top configuration level:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  ...\n  "proxy_publish_endpoint": "http://localhost:3000/centrifugo/publish",\n  "proxy_publish_timeout":  "1s",\n  "publish": true,\n  "proxy_publish": true\n}\n')),(0,r.kt)("p",null,"Or for channels in namespace ",(0,r.kt)("inlineCode",{parentName:"p"},"sun"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  ...\n  "proxy_publish_endpoint": "http://localhost:3000/centrifugo/publish",\n  "proxy_publish_timeout":  "1s",\n  "namespaces": [{\n    "name": "sun",\n    "publish": true,\n    "proxy_publish": true\n  }]\n}\n')),(0,r.kt)("p",null,"Keep in mind that this will only work if the ",(0,r.kt)("inlineCode",{parentName:"p"},"publish")," channel option is on for a channel namespace (or for a global top-level namespace)."),(0,r.kt)("p",null,"Payload example sent to app backend in a publish request:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "client":"9336a229-2400-4ebc-8c50-0a643d22e8a0",\n  "transport":"websocket",\n  "protocol": "json",\n  "encoding":"json",\n  "user":"56",\n  "channel": "chat:index",\n  "data":{"input":"hello"}\n}\n')),(0,r.kt)("p",null,"Expected response example if publish is allowed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"result": {}}\n')),(0,r.kt)("h4",{id:"publish-request-fields"},"Publish request fields"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Optional"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"client"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"unique client ID generated by Centrifugo for each incoming connection")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"transport"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"transport name (ex. ",(0,r.kt)("inlineCode",{parentName:"td"},"websocket"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"sockjs"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"protocol"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"protocol type used by the client (",(0,r.kt)("inlineCode",{parentName:"td"},"json")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"protobuf")," at moment)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"encoding"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"protocol encoding type used (",(0,r.kt)("inlineCode",{parentName:"td"},"json")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"binary")," at moment)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"user"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"a connection user ID obtained during authentication process")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"channel"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"a string channel client wants to publish to")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"data"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"data sent by client")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"b64data"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"will be set instead of ",(0,r.kt)("inlineCode",{parentName:"td"},"data")," field for binary proxy mode")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"meta"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a connection attached meta (off by default, enable with ",(0,r.kt)("inlineCode",{parentName:"td"},'"proxy_include_connection_meta": true'),")")))),(0,r.kt)("h4",{id:"publish-result-fields"},"Publish result fields"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Optional"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"data"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"an optional JSON data to send into a channel ",(0,r.kt)("strong",{parentName:"td"},"instead of")," original data sent by a client")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"b64data"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"a binary data encoded in base64 format, the meaning is the same as for data above, will be decoded to raw bytes on Centrifugo side before publishing")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"skip_history"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"when set to ",(0,r.kt)("inlineCode",{parentName:"td"},"true")," Centrifugo won't save publication to the channel history")))),(0,r.kt)("p",null,"See below on how to return an error in case you don't want to allow publishing."),(0,r.kt)("h4",{id:"options-4"},"Options"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"proxy_publish_timeout")," (float, in seconds) config option controls timeout of HTTP POST request sent to app backend."),(0,r.kt)("h3",{id:"return-custom-error"},"Return custom error"),(0,r.kt)("p",null,"Application backend can return JSON object that contains an error to return it to the client:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "error": {\n    "code": 1000,\n    "message": "custom error"\n  }\n}\n')),(0,r.kt)("p",null,"Application ",(0,r.kt)("strong",{parentName:"p"},"should use error codes >= 1000"),", error codes in the range 0-999 are reserved by Centrifugo internal protocol. Error code field is ",(0,r.kt)("inlineCode",{parentName:"p"},"uint32")," internally."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Returning custom error does not apply to response on refresh request as there is no sense in returning an error (will not reach client anyway). ")),(0,r.kt)("h3",{id:"return-custom-disconnect"},"Return custom disconnect"),(0,r.kt)("p",null,"Application backend can return JSON object that contains a custom disconnect object to disconnect client in a custom way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "disconnect": {\n    "code": 4000,\n    "reconnect": false,\n    "reason": "custom disconnect"\n  }\n}\n')),(0,r.kt)("p",null,"Application ",(0,r.kt)("strong",{parentName:"p"},"must use numbers in the range 4000-4999 for custom disconnect codes"),". Code is ",(0,r.kt)("inlineCode",{parentName:"p"},"uint32")," internally. Numbers below 4000 are reserved by Centrifugo internal protocol. Keep in mind that ",(0,r.kt)("strong",{parentName:"p"},"due to WebSocket protocol limitations and Centrifugo internal protocol needs you need to keep disconnect reason string no longer than 32 symbols"),"."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Returning custom disconnect does not apply to response on refresh request as there is no way to control disconnect at moment - the client will always be disconnected with ",(0,r.kt)("inlineCode",{parentName:"p"},"expired")," disconnect reason.")),(0,r.kt)("h2",{id:"grpc-proxy"},"GRPC proxy"),(0,r.kt)("p",null,"Centrifugo can also proxy connection events to your backend over GRPC instead of HTTP. In this case, Centrifugo acts as a GRPC client and your backend acts as a GRPC server."),(0,r.kt)("p",null,"GRPC service definitions can be found in the Centrifugo repository: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/centrifugo/blob/master/internal/proxyproto/proxy.proto"},"proxy.proto"),"."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"GRPC proxy inherits all the fields for HTTP proxy \u2013 so you can refer to field descriptions for HTTP above. Both proxy types in Centrifugo share the same Protobuf schema definitions.")),(0,r.kt)("p",null,"Every proxy call in this case is a unary GRPC call. Centrifugo puts client headers into GRPC metadata (since GRPC doesn't have headers concept)."),(0,r.kt)("p",null,"All you need to do to enable proxying over GRPC instead of HTTP is to use ",(0,r.kt)("inlineCode",{parentName:"p"},"grpc")," schema in endpoint, for example for the connect proxy:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="config.json"',title:'"config.json"'},'{\n  ...\n  "proxy_connect_endpoint": "grpc://localhost:12000",\n  "proxy_connect_timeout":  "1s"\n}\n')),(0,r.kt)("p",null,"Refresh proxy:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="config.json"',title:'"config.json"'},'{\n  ...\n  "proxy_refresh_endpoint": "grpc://localhost:12000",\n  "proxy_refresh_timeout":  "1s"\n}\n')),(0,r.kt)("p",null,"Or for RPC proxy:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="config.json"',title:'"config.json"'},'{\n  ...\n  "proxy_rpc_endpoint": "grpc://localhost:12000",\n  "proxy_rpc_timeout":  "1s"\n}\n')),(0,r.kt)("p",null,"For publish proxy in namespace ",(0,r.kt)("inlineCode",{parentName:"p"},"chat"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="config.json"',title:'"config.json"'},'{\n  ...\n  "proxy_publish_endpoint": "grpc://localhost:12000",\n  "proxy_publish_timeout":  "1s"\n  "namespaces": [\n    {\n      "name": "chat",\n      "publish": true,\n      "proxy_publish": true\n    }\n  ]\n}\n')),(0,r.kt)("p",null,"Use subscribe proxy for all channels without namespaces:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="config.json"',title:'"config.json"'},'{\n  ...\n  "proxy_subscribe_endpoint": "grpc://localhost:12000",\n  "proxy_subscribe_timeout":  "1s",\n  "proxy_subscribe": true\n}\n')),(0,r.kt)("p",null,"So the same as for HTTP, just the different endpoint scheme."),(0,r.kt)("h3",{id:"grpc-proxy-options"},"GRPC proxy options"),(0,r.kt)("p",null,"Some additional options exist to control GRPC proxy behavior."),(0,r.kt)("h4",{id:"proxy_grpc_cert_file"},"proxy_grpc_cert_file"),(0,r.kt)("p",null,"String, default: ",(0,r.kt)("inlineCode",{parentName:"p"},'""'),"."),(0,r.kt)("p",null,"Path to cert file for secure TLS connection. If not set then an insecure connection with the backend endpoint is used."),(0,r.kt)("h4",{id:"proxy_grpc_credentials_key"},"proxy_grpc_credentials_key"),(0,r.kt)("p",null,"String, default ",(0,r.kt)("inlineCode",{parentName:"p"},'""')," (i.e. not used)."),(0,r.kt)("p",null,"Add custom key to per-RPC credentials."),(0,r.kt)("h4",{id:"proxy_grpc_credentials_value"},"proxy_grpc_credentials_value"),(0,r.kt)("p",null,"String, default ",(0,r.kt)("inlineCode",{parentName:"p"},'""')," (i.e. not used)."),(0,r.kt)("p",null,"A custom value for ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy_grpc_credentials_key"),"."),(0,r.kt)("h3",{id:"grpc-proxy-example"},"GRPC proxy example"),(0,r.kt)("p",null,"We have ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/examples/tree/master/v3/proxy/grpc"},"an example of backend server")," (written in Go language) which can react to events from Centrifugo over GRPC. For other programming languages the approach is similar, i.e.:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Copy proxy Protobuf definitions"),(0,r.kt)("li",{parentName:"ol"},"Generate GRPC code"),(0,r.kt)("li",{parentName:"ol"},"Run backend service with you custom business logic"),(0,r.kt)("li",{parentName:"ol"},"Point Centrifugo to it.")),(0,r.kt)("h2",{id:"header-proxy-rules"},"Header proxy rules"),(0,r.kt)("p",null,"Centrifugo not only supports HTTP-based client transports but also GRPC-based (for example GRPC unidirectional stream). Here is a table with rules used to proxy headers/metadata in various scenarios:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Client protocol type"),(0,r.kt)("th",{parentName:"tr",align:null},"Proxy type"),(0,r.kt)("th",{parentName:"tr",align:null},"Client headers"),(0,r.kt)("th",{parentName:"tr",align:null},"Client metadata"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"HTTP"),(0,r.kt)("td",{parentName:"tr",align:null},"HTTP"),(0,r.kt)("td",{parentName:"tr",align:null},"In proxy request headers"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GRPC"),(0,r.kt)("td",{parentName:"tr",align:null},"GRPC"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"In proxy request metadata")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"HTTP"),(0,r.kt)("td",{parentName:"tr",align:null},"GRPC"),(0,r.kt)("td",{parentName:"tr",align:null},"In proxy request metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GRPC"),(0,r.kt)("td",{parentName:"tr",align:null},"HTTP"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"In proxy request headers")))),(0,r.kt)("h2",{id:"binary-mode"},"Binary mode"),(0,r.kt)("p",null,"As you may noticed there are several fields in request/result description of various proxy calls which use ",(0,r.kt)("inlineCode",{parentName:"p"},"base64")," encoding."),(0,r.kt)("p",null,"Centrifugo can work with binary Protobuf protocol (in case of bidirectional WebSocket transport). All our bidirectional clients support this."),(0,r.kt)("p",null,"Most Centrifugo users use JSON for custom payloads: i.e. for data sent to a channel, for connection info attached while authenticating (which becomes part of presence response, join/leave messages and added to Publication client info when message published from a client side)."),(0,r.kt)("p",null,"But since HTTP proxy works with JSON format (i.e. sends requests with JSON body) \u2013 it can not properly pass binary data to application backend. Arbitrary binary data can't be encoded into JSON."),(0,r.kt)("p",null,"In this case it's possible to turn Centrifugo proxy into binary mode by using:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="config.json"',title:'"config.json"'},'{\n  ...\n  "proxy_binary_encoding": true\n}\n')),(0,r.kt)("p",null,"Once enabled this option tells Centrifugo to use base64 format in requests and utilize fields like ",(0,r.kt)("inlineCode",{parentName:"p"},"b64data"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"b64info")," with payloads encoded to base64 instead of their JSON field analogues."),(0,r.kt)("p",null,"While this feature is useful for HTTP proxy it's not really required if you are using GRPC proxy \u2013 since GRPC allows passing binary data just fine."),(0,r.kt)("p",null,"Regarding b64 fields in proxy results \u2013 just use base64 fields when required \u2013 Centrifugo is smart enough to detect that you are using base64 field and will pick payload from it, decode from base64 automatically and will pass further to connections in binary format."),(0,r.kt)("h2",{id:"granular-proxy-mode"},"Granular proxy mode"),(0,r.kt)("p",null,"New in Centrifugo v3.1.0."),(0,r.kt)("p",null,"By default, with proxy configuration shown above, you can only define a global proxy settings and one endpoint for each type of proxy (i.e. one for connect proxy, one for subscribe proxy, and so on). Also, you can configure only one set of headers to proxy which will be used by each proxy type. This may be sufficient for many use cases, but what if you need a more granular control? For example, use different subscribe proxy endpoints for different channel namespaces (i.e. when using microservice architecture)."),(0,r.kt)("p",null,"Centrifugo v3.1.0 introduced a new mode for proxy configuration called granular proxy mode. In this mode it's possible to configure subscribe and publish proxy behaviour on per-namespace level, use different set of headers passed to the proxy endpoint in each proxy type. Also, Centrifugo v3.1.0 introduced a concept of rpc namespaces (in addition to channel namespaces) \u2013 together with granular proxy mode this allows configuring rpc proxies on per rpc namespace basis."),(0,r.kt)("h3",{id:"enable-granular-proxy-mode"},"Enable granular proxy mode"),(0,r.kt)("p",null,"Since the change is rather radical it requires a separate boolean option ",(0,r.kt)("inlineCode",{parentName:"p"},"granular_proxy_mode")," to be enabled. As soon as this option set Centrifugo does not use proxy configuration rules described above and follows the rules described below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="config.json"',title:'"config.json"'},'{\n  ...\n  "granular_proxy_mode": true\n}\n')),(0,r.kt)("h3",{id:"defining-a-list-of-proxies"},"Defining a list of proxies"),(0,r.kt)("p",null,"When using granular proxy mode on configuration top level you can define ",(0,r.kt)("inlineCode",{parentName:"p"},'"proxies"')," array with a list of different proxy objects. Each proxy object in an array should have at least two required fields: ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"endpoint"),"."),(0,r.kt)("p",null,"Here is an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="config.json"',title:'"config.json"'},'{\n  ...\n  "granular_proxy_mode": true,\n  "proxies": [\n    {\n      "name": "connect",\n      "endpoint": "http://localhost:3000/centrifugo/connect",\n      "timeout": "500ms",\n      "http_headers": ["Cookie"]\n    },\n    {\n      "name": "refresh",\n      "endpoint": "http://localhost:3000/centrifugo/refresh",\n      "timeout": "500ms"\n    },\n    {\n      "name": "subscribe1",\n      "endpoint": "http://localhost:3001/centrifugo/subscribe"\n    },\n    {\n      "name": "publish1",\n      "endpoint": "http://localhost:3001/centrifugo/publish"\n    },\n    {\n      "name": "rpc1",\n      "endpoint": "http://localhost:3001/centrifugo/rpc"\n    },\n    {\n      "name": "subscribe2",\n      "endpoint": "http://localhost:3002/centrifugo/subscribe"\n    },\n    {\n      "name": "publish2",\n      "endpoint": "grpc://localhost:3002"\n    }\n    {\n      "name": "rpc2",\n      "endpoint": "grpc://localhost:3002"\n    }\n  ]\n}\n')),(0,r.kt)("p",null,"Let's look at all fields for a proxy object which is possible to set for each proxy inside ",(0,r.kt)("inlineCode",{parentName:"p"},'"proxies"')," array."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field name"),(0,r.kt)("th",{parentName:"tr",align:null},"Field type"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"name"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Unique name of proxy used for referencing in configuration, must match regexp ",(0,r.kt)("inlineCode",{parentName:"td"},"^[-a-zA-Z0-9_.]{2,}$"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"endpoint"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"HTTP or GRPC endpoint in the same format as in default proxy mode. For example, ",(0,r.kt)("inlineCode",{parentName:"td"},"http://localhost:3000/path")," for HTTP or ",(0,r.kt)("inlineCode",{parentName:"td"},"grpc://localhost:3000")," for GRPC.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"timeout"),(0,r.kt)("td",{parentName:"tr",align:null},"duration (string)"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"Proxy request timeout, default ",(0,r.kt)("inlineCode",{parentName:"td"},'"1s"'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"http_headers"),(0,r.kt)("td",{parentName:"tr",align:null},"array of strings"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"List of headers to proxy, by default no headers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"grpc_metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"array of strings"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"List of GRPC metadata keys to proxy, by default no metadata keys")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"binary_encoding"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"Use base64 for payloads")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"include_connection_meta"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"Include meta information (attached on connect)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"grpc_cert_file"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"Path to cert file for secure TLS connection. If not set then an insecure connection with the backend endpoint is used.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"grpc_credentials_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"Add custom key to per-RPC credentials.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"grpc_credentials_value"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"A custom value for ",(0,r.kt)("inlineCode",{parentName:"td"},"grpc_credentials_key"),".")))),(0,r.kt)("h3",{id:"granular-connect-and-refresh"},"Granular connect and refresh"),(0,r.kt)("p",null,"As soon as you defined a list of proxies you can reference them by a name to use a specific proxy configuration for a specific event."),(0,r.kt)("p",null,"To enable connect proxy:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="config.json"',title:'"config.json"'},'{\n  ...\n  "granular_proxy_mode": true,\n  "proxies": [...],\n  "connect_proxy_name": "connect"\n}\n')),(0,r.kt)("p",null,"We have an ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/examples/tree/master/v3/nodejs_granular_proxy"},"example of Centrifugo integration with NodeJS")," which uses granular proxy mode. Even if you are not using NodeJS on a backend an example can help you understand the idea."),(0,r.kt)("p",null,"Let's also add refresh proxy:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="config.json"',title:'"config.json"'},'{\n  ...\n  "granular_proxy_mode": true,\n  "proxies": [...],\n  "connect_proxy_name": "connect",\n  "refresh_proxy_name": "refresh"\n}\n')),(0,r.kt)("h3",{id:"granular-subscribe-and-publish"},"Granular subscribe and publish"),(0,r.kt)("p",null,"Subscribe and publish proxy work per-namespace. This means that ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe_proxy_name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"publish_proxy_name")," are just a channel namespace options. So it's possible to define these options on configuration top-level (for channels in default top-level namespace) or inside namespace object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="config.json"',title:'"config.json"'},'{\n  ...\n  "granular_proxy_mode": true,\n  "proxies": [...],\n  "namespaces": [\n    {\n      "name": "ns1",\n      "subscribe_proxy_name": "subscribe1",\n      "publish": true,\n      "publish_proxy_name": "publish1"\n    },\n    {\n      "name": "ns2",\n      "subscribe_proxy_name": "subscribe2",\n      "publish": true,\n      "publish_proxy_name": "publish2"\n    }\n  ]\n}\n')),(0,r.kt)("p",null,"If namespace does not have ",(0,r.kt)("inlineCode",{parentName:"p"},'"subscribe_proxy_name"')," or ",(0,r.kt)("inlineCode",{parentName:"p"},'"subscribe_proxy_name"')," is empty then no subscribe proxy will be used for a namespace."),(0,r.kt)("p",null,"If namespace does not have ",(0,r.kt)("inlineCode",{parentName:"p"},'"publish_proxy_name"')," or ",(0,r.kt)("inlineCode",{parentName:"p"},'"publish_proxy_name"')," is empty then no publish proxy will be used for a namespace."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"You can define ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe_proxy_name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"publish_proxy_name")," on configuration top level \u2013 and in this case publish and subscribe requests for channels without explicit namespace will be proxied using this proxy. The same mechanics as for other channel options in Centrifugo.")),(0,r.kt)("h3",{id:"granular-rpc"},"Granular RPC"),(0,r.kt)("p",null,"Analogous to channel namespaces it's possible to configure rpc namespaces:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="config.json"',title:'"config.json"'},'{\n  ...\n  "granular_proxy_mode": true,\n  "proxies": [...],\n  "namespaces": [...],\n  "rpc_namespaces": [\n    {\n      "name": "rpc_ns1",\n      "rpc_proxy_name": "rpc1",\n    },\n    {\n      "name": "rpc_ns2",\n      "rpc_proxy_name": "rpc2"\n    }\n  ]\n}\n')),(0,r.kt)("p",null,"The mechanics is the same as for channel namespaces. RPC requests with RPC method like ",(0,r.kt)("inlineCode",{parentName:"p"},"rpc_ns1:test")," will use rpc proxy ",(0,r.kt)("inlineCode",{parentName:"p"},"rpc1"),", RPC requests with RPC method like ",(0,r.kt)("inlineCode",{parentName:"p"},"rpc_ns2:test")," will use rpc proxy ",(0,r.kt)("inlineCode",{parentName:"p"},"rpc2"),". So Centrifugo uses ",(0,r.kt)("inlineCode",{parentName:"p"},":")," as RPC namespace boundary in RPC method (just like it does for channel namespaces)."),(0,r.kt)("p",null,"Just like channel namespaces RPC namespaces should have a name which match ",(0,r.kt)("inlineCode",{parentName:"p"},"^[-a-zA-Z0-9_.]{2,}$")," regexp pattern \u2013 this is validated on Centrifugo start."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The same as for channel namespaces and channel options you can define ",(0,r.kt)("inlineCode",{parentName:"p"},"rpc_proxy_name")," on configuration top level \u2013 and in this case RPC calls without explicit namespace in RPC method will be proxied using this proxy.")))}u.isMDXComponent=!0},330:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/diagram_connect_proxy-4318d8beb2c7553d9b30b2ed7fb8edac.png"},8719:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/diagram_publish_proxy-66ccb1e8b37ed8912d218b4529597bd9.png"}}]);