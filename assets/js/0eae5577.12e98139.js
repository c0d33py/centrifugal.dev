"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[5048],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(t),h=i,b=d["".concat(l,".").concat(h)]||d[h]||p[h]||o;return t?a.createElement(b,r(r({ref:n},u),{},{components:t})):a.createElement(b,r({ref:n},u))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},5162:(e,n,t)=>{t.d(n,{Z:()=>r});var a=t(7294),i=t(6010);const o="tabItem_Ymn6";function r(e){let{children:n,hidden:t,className:r}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(o,r),hidden:t},n)}},4866:(e,n,t)=>{t.d(n,{Z:()=>C});var a=t(7462),i=t(7294),o=t(6010),r=t(6775),s=t(1980),l=t(7392),c=t(12);function u(e){return function(e){var n;return(null==(n=i.Children.map(e,(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:n.filter(Boolean))??[]}(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:i}}=e;return{value:n,label:t,attributes:a,default:i}}))}function p(e){const{values:n,children:t}=e;return(0,i.useMemo)((()=>{const e=n??u(t);return function(e){const n=(0,l.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function d(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function h(e){let{queryString:n=!1,groupId:t}=e;const a=(0,r.k6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,s._X)(o),(0,i.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(a.location.search);n.set(o,e),a.replace({...a.location,search:n.toString()})}),[o,a])]}function b(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,o=p(e),[r,s]=(0,i.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!d({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:o}))),[l,u]=h({queryString:t,groupId:a}),[b,m]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,o]=(0,c.Nk)(t);return[a,(0,i.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:a}),f=(()=>{const e=l??b;return d({value:e,tabValues:o})?e:null})();(0,i.useLayoutEffect)((()=>{f&&s(f)}),[f]);return{selectedValue:r,selectValue:(0,i.useCallback)((e=>{if(!d({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);s(e),u(e),m(e)}),[u,m,o]),tabValues:o}}var m=t(2466),f=t(2389);const g="tabList__CuJ",k="tabItem_LNqP";function y(e){let{className:n,block:t,selectedValue:r,selectValue:s,tabValues:l}=e;const c=[],{blockElementScrollPositionUntilNextRender:u}=(0,m.o5)(),p=e=>{const n=e.currentTarget,t=c.indexOf(n),a=l[t].value;a!==r&&(u(n),s(a))},d=e=>{var n;let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}null==(n=t)||n.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},n)},l.map((e=>{let{value:n,label:t,attributes:s}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,key:n,ref:e=>c.push(e),onKeyDown:d,onClick:p},s,{className:(0,o.Z)("tabs__item",k,null==s?void 0:s.className,{"tabs__item--active":r===n})}),t??n)})))}function v(e){let{lazy:n,children:t,selectedValue:a}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===a));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},o.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==a}))))}function w(e){const n=b(e);return i.createElement("div",{className:(0,o.Z)("tabs-container",g)},i.createElement(y,(0,a.Z)({},e,n)),i.createElement(v,(0,a.Z)({},e,n)))}function C(e){const n=(0,f.Z)();return i.createElement(w,(0,a.Z)({key:String(n)},e))}},204:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>p});var a=t(7462),i=(t(7294),t(3905)),o=t(4866),r=t(5162);const s={title:"101 ways to subscribe user on a personal channel in Centrifugo",tags:["centrifugo","tutorial"],description:"In this post we are discussing vaious ways developers can use to subscribe user to a personal channel in Centrifugo",author:"Alexander Emelin",authorTitle:"Author of Centrifugo",authorImageURL:"https://github.com/FZambia.png",image:"/img/101-way.png",hide_table_of_contents:!1},l=void 0,c={permalink:"/blog/2022/07/29/101-way-to-subscribe",editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/blog/2022-07-29-101-way-to-subscribe.md",source:"@site/blog/2022-07-29-101-way-to-subscribe.md",title:"101 ways to subscribe user on a personal channel in Centrifugo",description:"In this post we are discussing vaious ways developers can use to subscribe user to a personal channel in Centrifugo",date:"2022-07-29T00:00:00.000Z",formattedDate:"July 29, 2022",tags:[{label:"centrifugo",permalink:"/blog/tags/centrifugo"},{label:"tutorial",permalink:"/blog/tags/tutorial"}],readingTime:10.64,hasTruncateMarker:!0,authors:[{name:"Alexander Emelin",title:"Author of Centrifugo",imageURL:"https://github.com/FZambia.png"}],frontMatter:{title:"101 ways to subscribe user on a personal channel in Centrifugo",tags:["centrifugo","tutorial"],description:"In this post we are discussing vaious ways developers can use to subscribe user to a personal channel in Centrifugo",author:"Alexander Emelin",authorTitle:"Author of Centrifugo",authorImageURL:"https://github.com/FZambia.png",image:"/img/101-way.png",hide_table_of_contents:!1},prevItem:{title:"Improving Centrifugo Redis Engine throughput and allocation efficiency with Rueidis Go library",permalink:"/blog/2022/12/20/improving-redis-engine-performance"},nextItem:{title:"Centrifugo v4 released \u2013 a little revolution",permalink:"/blog/2022/07/19/centrifugo-v4-released"}},u={authorsImageUrls:[void 0]},p=[{value:"Setup",id:"setup",level:2},{value:"#1 \u2013 user-limited channel",id:"1--user-limited-channel",level:2},{value:"#2 - channel token authorization",id:"2---channel-token-authorization",level:2},{value:"#3 - subscribe proxy",id:"3---subscribe-proxy",level:2},{value:"#4 - server-side channel in connection JWT",id:"4---server-side-channel-in-connection-jwt",level:2},{value:"#5 - server-side channel in connect proxy",id:"5---server-side-channel-in-connect-proxy",level:2},{value:"#6 - automatic personal channel subscription",id:"6---automatic-personal-channel-subscription",level:2},{value:"#7 \u2013 capabilities in connection JWT",id:"7--capabilities-in-connection-jwt",level:2},{value:"#8 \u2013 capabilities in connect proxy",id:"8--capabilities-in-connect-proxy",level:2},{value:"Teardown",id:"teardown",level:2}],d={toc:p};function h(e){let{components:n,...s}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,s,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Centrifuge",src:t(5583).Z,width:"1600",height:"542"})),(0,i.kt)("p",null,"Let's say you develop an application and want a real-time connection which is subscribed to one channel. Let's also assume that this channel is used for user personal notifications. So only one user in the application can subcribe to that channel to receive its notifications in real-time."),(0,i.kt)("p",null,"In this post we will look at various ways to achieve this with Centrifugo, and consider trade-offs of the available approaches. The main goal of this tutorial is to help Centrifugo newcomers be aware of all the ways to control channel permissions by reading just one document."),(0,i.kt)("p",null,"And... well, there are actually 8 ways I found, not 101 \ud83d\ude07"),(0,i.kt)("h2",{id:"setup"},"Setup"),(0,i.kt)("p",null,"To make the post a bit easier to consume let's setup some things. Let's assume that the user for which we provide all the examples in this post has ID ",(0,i.kt)("inlineCode",{parentName:"p"},'"17"'),". Of course in real-life the examples given here can be extrapolated to any user ID."),(0,i.kt)("p",null,"When you create a real-time connection to Centrifugo the connection is authenticated using the one of the following ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"using ",(0,i.kt)("a",{parentName:"li",href:"/docs/server/authentication"},"connection JWT")),(0,i.kt)("li",{parentName:"ul"},"using connection request proxy from Centrifugo to the configured endpoint of the application backend (",(0,i.kt)("a",{parentName:"li",href:"/docs/server/proxy#connect-proxy"},"connect proxy"),")")),(0,i.kt)("p",null,"As soon as the connection is successfully established and authenticated Centrifugo knows the ID of connected user. This is important to understand."),(0,i.kt)("p",null,"And let's define a namespace in Centrifugo configuration which will be used for personal user channels:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    ...\n    "namespaces": [\n        {\n            "name": "personal",\n            "presence": true\n        }\n    ]\n}\n')),(0,i.kt)("p",null,"Defining namespaces for each new real-time feature is a good practice in Centrifugo. As an awesome improvement we also enabled ",(0,i.kt)("inlineCode",{parentName:"p"},"presence")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"personal")," namespace, so whenever users subscribe to a channel in this namespace Centrifugo will maintain online presence information for each channel. So you can find out all connections of the specific user existing at any moment. Defining ",(0,i.kt)("inlineCode",{parentName:"p"},"presence")," is fully optional though - turn it of if you don't need presence information and don't want to spend additional server resources on maintaining presence."),(0,i.kt)("h2",{id:"1--user-limited-channel"},"#1 \u2013 user-limited channel"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Probably the most performant approach.")),(0,i.kt)("p",null,"All you need to do is to extend namespace configuration with ",(0,i.kt)("inlineCode",{parentName:"p"},"allow_user_limited_channels")," option:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "namespaces": [\n        {\n            "name": "personal",\n            "presence": true,\n            "allow_user_limited_channels": true\n        }\n    ]\n}\n')),(0,i.kt)("p",null,"On the client side you need to have sth like this (of course the ID of current user will be dynamic in real-life):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const sub = centrifuge.newSubscription('personal:#17');\nsub.on('publication', function(ctx) {\n    console.log(ctx.data);\n})\nsub.subscribe();\n")),(0,i.kt)("p",null,"Here you are subscribing to a channel in ",(0,i.kt)("inlineCode",{parentName:"p"},"personal")," namespace and listening to publications coming from a channel. Having ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," in channel name tells Centrifugo that this is a user-limited channel (because ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," is a special symbol that is treated in a special way by Centrifugo as soon as ",(0,i.kt)("inlineCode",{parentName:"p"},"allow_user_limited_channels")," enabled)."),(0,i.kt)("p",null,"In this case the user ID part of user-limited channel is ",(0,i.kt)("inlineCode",{parentName:"p"},'"17"'),". So Centrifugo allows user with ID ",(0,i.kt)("inlineCode",{parentName:"p"},'"17"')," to subscribe on ",(0,i.kt)("inlineCode",{parentName:"p"},"personal:#17")," channel. Other users won't be able to subscribe on it."),(0,i.kt)("p",null,"To publish updates to subscription all you need to do is to publish to ",(0,i.kt)("inlineCode",{parentName:"p"},"personal:#17")," using server publish API (HTTP or GRPC)."),(0,i.kt)("h2",{id:"2---channel-token-authorization"},"#2 - channel token authorization"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Probably the most flexible approach, with reasonably good performance characteristics.")),(0,i.kt)("p",null,"Another way we will look at is using subscription JWT for subscribing. When you create Subscription object on the client side you can pass it a subscription token, and also provide a function to retrieve subscription token (useful to automatically handle token refresh, it also handles initial token loading)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const token = await getSubscriptionToken('personal:17');\n\nconst sub = centrifuge.newSubscription('personal:17', {\n    token: token\n});\nsub.on('publication', function(ctx) {\n    console.log(ctx.data);\n})\nsub.subscribe();\n")),(0,i.kt)("p",null,"Inside ",(0,i.kt)("inlineCode",{parentName:"p"},"getSubscriptionToken")," you can issue a request to the backend, for example in browser it's possible to do with fetch API."),(0,i.kt)("p",null,"On the backend side you know the ID of current user due to the native session mechanism of your app, so you can decide whether current user has permission to subsribe on ",(0,i.kt)("inlineCode",{parentName:"p"},"personal:17")," or not. If yes \u2013 return subscription JWT according to our rules. If not - return empty string so subscription will go to unsubscribed state with ",(0,i.kt)("inlineCode",{parentName:"p"},"unauthorized")," reason."),(0,i.kt)("p",null,"Here are examples for generating subscription HMAC SHA-256 JWTs for channel ",(0,i.kt)("inlineCode",{parentName:"p"},"personal:17")," and HMAC secret key ",(0,i.kt)("inlineCode",{parentName:"p"},"secret"),":"),(0,i.kt)(o.Z,{className:"unique-tabs",defaultValue:"python",values:[{label:"Python",value:"python"},{label:"NodeJS",value:"node"}],mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"python",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'import jwt\nimport time\n\nclaims = {\n    "sub": "17",\n    "channel": "personal:17"\n    "exp": int(time.time()) + 30*60\n}\n\ntoken = jwt.encode(claims, "secret", algorithm="HS256").decode()\nprint(token)\n'))),(0,i.kt)(r.Z,{value:"node",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const jose = require('jose')\n\n(async function main() {\n  const secret = new TextEncoder().encode('secret')\n  const alg = 'HS256'\n\n  const token = await new jose.SignJWT({ 'sub': '17', 'channel': 'personal:17' })\n    .setProtectedHeader({ alg })\n    .setExpirationTime('30m')\n    .sign(secret)\n\n  console.log(token);\n})();\n")))),(0,i.kt)("p",null,"Since we set expiration time for subscription JWT tokens we also need to provide a ",(0,i.kt)("inlineCode",{parentName:"p"},"getToken")," function to a client on the frontend side:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const sub = centrifuge.newSubscription('personal:17', {\n    getToken: async function (ctx) {\n        const token = await getSubscriptionToken('personal:17');\n        return token;\n    }\n});\nsub.on('publication', function(ctx) {\n    console.log(ctx.data);\n})\nsub.subscribe();\n")),(0,i.kt)("p",null,"This function will be called by SDK automatically to refresh subscription token when it's going to expire. And note that we omitted setting ",(0,i.kt)("inlineCode",{parentName:"p"},"token")," option here \u2013 since SDK is smart enough to call provided ",(0,i.kt)("inlineCode",{parentName:"p"},"getToken")," function to extract initial subscription token from the backend."),(0,i.kt)("p",null,"The good thing in using subscription JWT approach is that you can provide token expiration time, so permissions to subscribe on a channel will be validated from time to time while connection is active. You can also provide additional channel context info which will be attached to presence information (using ",(0,i.kt)("inlineCode",{parentName:"p"},"info")," claim of subscription JWT). And you can granularly control channel permissions using ",(0,i.kt)("inlineCode",{parentName:"p"},"allow")," claim of token \u2013 and give client capabilities to publish, call history or presence information (this is Centrifugo PRO feature at this point). Token also allows to override some namespace options on per-subscription basis (with ",(0,i.kt)("inlineCode",{parentName:"p"},"override")," claim)."),(0,i.kt)("p",null,"Using subscription tokens is a general approach for any channels where you need to check access first, not only for personal user channels."),(0,i.kt)("h2",{id:"3---subscribe-proxy"},"#3 - subscribe proxy"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Probably the most secure approach.")),(0,i.kt)("p",null,"Subscription JWT gives client a way to subscribe on a channel, and avoid requesting your backend for permission on every resubscribe. Token approach is very good in massive reconnect scenario, when you have many connections and they all resubscribe at once (due to your load balancer reload, for example). But this means that if you unsubscribed client from a channel using server API, client can still resubscribe with token again - until token will expire. In some cases you may want to avoid this."),(0,i.kt)("p",null,"Also, in some cases you want to be notified when someone subscribes to a channel."),(0,i.kt)("p",null,"In this case you may use subscribe proxy feature. When using subscribe proxy every attempt of a client to subscribe on a channel will be translated to request (HTTP or GRPC) from Centrifugo to the application backend. Application backend can decide whether client is allowed to subscribe or not."),(0,i.kt)("p",null,"One advantage of using subscribe proxy is that backend can additionally provide initial channel data for the subscribing client. This is possible using ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," field of subscribe result generated by backend subscribe handler."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "proxy_subscribe_endpoint": "http://localhost:9000/centrifugo/subscribe",\n    "namespaces": [\n        {\n            "name": "personal",\n            "presence": true,\n            "proxy_subscribe": true\n        }\n    ]\n}\n')),(0,i.kt)("p",null,"And on the backend side define a route ",(0,i.kt)("inlineCode",{parentName:"p"},"/centrifugo/subscribe"),", check permissions of user upon subscription and return result to Centrifugo according to our subscribe proxy docs. Or simply run GRPC server using our proxy definitions and react on subscription attempt sent from Centrifugo to backend over GRPC."),(0,i.kt)("p",null,"On the client-side code is as simple as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const sub = centrifuge.newSubscription('personal:17');\nsub.on('publication', function(ctx) {\n    console.log(ctx.data);\n})\nsub.subscribe();\n")),(0,i.kt)("h2",{id:"4---server-side-channel-in-connection-jwt"},"#4 - server-side channel in connection JWT"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The approach where you don't need to manage client-side subscriptions.")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/server/server_subs"},"Server-side subscriptions")," is a way to consume publications from channels without even create Subscription objects on the client side. In general, client side Subscription objects provide a more flexible and controllable way to work with subscriptions. Clients can subscribe/unsubscribe on channels at any point. Client-side subscriptions provide more details about state transitions."),(0,i.kt)("p",null,"With server-side subscriptions though you are consuming publications directly from Client instance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const client = new Centrifuge('ws://localhost:8000/connection/websocket', {\n    token: 'CONNECTION-JWT'\n});\nclient.on('publication', function(ctx) {\n    console.log('publication received from server-side channel', ctx.channel, ctx.data);\n});\nclient.connect();\n")),(0,i.kt)("p",null,"In this case you don't have separate Subscription objects and need to look at ",(0,i.kt)("inlineCode",{parentName:"p"},"ctx.channel")," upon receiving publication or to publication content to decide how to handle it. Server-side subscriptions could be a good choice if you are using Centrifugo unidirectional transports and don't need dynamic subscribe/unsubscribe behavior."),(0,i.kt)("p",null,"The first way to subscribe client on a server-side channel is to include ",(0,i.kt)("inlineCode",{parentName:"p"},"channels")," claim into connection JWT:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "sub": "17",\n    "channels": ["personal:17"]\n}\n')),(0,i.kt)("p",null,"Upon successful connection user will be subscribed to a server-side channel by Centrifugo. One downside of using server-side channels is that errors in one server-side channel (like impossible to recover missed messages) may affect the entire connection and result into reconnects, while with client-side subscriptions individual subsription failures do not affect the entire connection."),(0,i.kt)("p",null,"But having one server-side channel per-connection seems a very reasonable idea to me in many cases. And if you have stable set of subscriptions which do not require lifetime state management \u2013 this can be a nice approach without additional protocol/network overhead involved."),(0,i.kt)("h2",{id:"5---server-side-channel-in-connect-proxy"},"#5 - server-side channel in connect proxy"),(0,i.kt)("p",null,"Similar to the previous one for cases when you are authenticating connections over connect proxy instead of using JWT."),(0,i.kt)("p",null,"This is possible using ",(0,i.kt)("inlineCode",{parentName:"p"},"channels")," field of connect proxy handler result. The code on the client-side is the same as in Option #4 \u2013 since we only change the way how list of server-side channels is provided."),(0,i.kt)("h2",{id:"6---automatic-personal-channel-subscription"},"#6 - automatic personal channel subscription"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Almost no code approach.")),(0,i.kt)("p",null,"As we pointed above Centrifugo knows an ID of the user due to authentication process. So why not combining this knowledge with automatic server-side personal channel subscription? Centrifugo provides exactly this with user personal channel feature."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "user_subscribe_to_personal": true,\n    "user_personal_channel_namespace": "personal",\n    "namespaces": [\n        {\n            "name": "personal",\n            "presence": true\n        }\n    ]\n}\n')),(0,i.kt)("p",null,"This feature only subscribes non-anonymous users to personal channels (those with non-empty user ID). The configuration above will subscribe our user ",(0,i.kt)("inlineCode",{parentName:"p"},'"17"')," to channel ",(0,i.kt)("inlineCode",{parentName:"p"},"personal:#17")," automatically after successful authentication."),(0,i.kt)("h2",{id:"7--capabilities-in-connection-jwt"},"#7 \u2013 capabilities in connection JWT"),(0,i.kt)("p",null,"Allows using client-side subscriptions, but skip receiving subscription token. This is only available in Centrifugo PRO at this point."),(0,i.kt)("p",null,"So when generating JWT you can provide additional ",(0,i.kt)("inlineCode",{parentName:"p"},"caps")," claim which contains channel resource capabilities:"),(0,i.kt)(o.Z,{className:"unique-tabs",defaultValue:"python",values:[{label:"Python",value:"python"},{label:"NodeJS",value:"node"}],mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"python",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'import jwt\nimport time\n\nclaims = {\n    "sub": "17",\n    "exp": int(time.time()) + 30*60,\n    "caps": [\n        {\n            "channels": ["personal:17"],\n            "allow": ["sub"]\n        }\n    ]\n}\n\ntoken = jwt.encode(claims, "secret", algorithm="HS256").decode()\nprint(token)\n'))),(0,i.kt)(r.Z,{value:"node",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const jose = require('jose');\n\n(async function main() {\n  const secret = new TextEncoder().encode('secret')\n  const alg = 'HS256'\n\n  const token = await new jose.SignJWT({\n    sub: '17',\n    caps: [\n      {\n        \"channels\": [\"personal:17\"],\n        \"allow\": [\"sub\"]\n      }\n    ]\n  })\n    .setProtectedHeader({ alg })\n    .setExpirationTime('30m')\n    .sign(secret)\n\n  console.log(token);\n})();\n")))),(0,i.kt)("p",null,"While in case of single channel the benefit of using this approach is not really obvious, it can help when you are using several channels with stric access permissions per connection, where providing capabilities can help to save some traffic and CPU resources since we avoid generating subscription token for each individual channel."),(0,i.kt)("h2",{id:"8--capabilities-in-connect-proxy"},"#8 \u2013 capabilities in connect proxy"),(0,i.kt)("p",null,"This is very similar to the previous approach, but capabilities are passed to Centrifugo in connect proxy result. So if you are using connect proxy for auth then you can still provide capabilities in the same form as in JWT. This is also a Centrifugo PRO feature."),(0,i.kt)("h2",{id:"teardown"},"Teardown"),(0,i.kt)("p",null,"Which way to choose? Well, it depends. Since your application will have more than only a personal user channel in many cases you should decide which approach suits you better in each particular case \u2013 it's hard to give the universal advice."),(0,i.kt)("p",null,"Client-side subscriptions are more flexible in general, so I'd suggest using them whenever possible. Though you may use unidirectional transports of Centrifugo where subscribing to channels from the client side is not simple to achieve (though still possible using our server subscribe API). Server-side subscriptions make more sense there."),(0,i.kt)("p",null,"The good news is that all our official bidirectional client SDKs support all the approaches mentioned in this post. Hope designing the channel configuration on top of Centrifugo will be a pleasant experience for you."),(0,i.kt)("admonition",{title:"Attributions",type:"note"},(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{href:"https://www.freepik.com/vectors/internet-network"},"Internet network vector created by rawpixel.com - www.freepik.com")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{href:"https://www.flaticon.com/free-icons/cyber-security",title:"cyber security icons"},"Cyber security icons created by Smashicons - Flaticon")))))}h.isMDXComponent=!0},5583:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/101-way-c2185f0f2f7d884bd0a95f8c37d14b2a.png"}}]);