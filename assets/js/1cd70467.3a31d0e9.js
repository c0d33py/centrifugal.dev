"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[6533],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>p});var r=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(t),p=o,g=d["".concat(l,".").concat(p)]||d[p]||m[p]||i;return t?r.createElement(g,a(a({ref:n},u),{},{components:t})):r.createElement(g,a({ref:n},u))}));function p(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=t[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},87631:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=t(87462),o=(t(67294),t(3905));const i={title:"Million connections with Centrifugo",tags:["centrifuge","go"],description:"Describing a test stand in Kubernetes where we connect one million websocket connections to a server, using Redis to scale nodes, and providing insights about hardware resources required to achieve 500k messages per second",author:"Centrifugal team",authorTitle:"Let the Centrifugal force be with you",authorImageURL:"/img/logo_animated.svg",image:"/img/million_conns.jpg",hide_table_of_contents:!1},a=void 0,s={permalink:"/blog/2020/02/10/million-connections-with-centrifugo",editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/blog/2020-02-10-million-connections-with-centrifugo.md",source:"@site/blog/2020-02-10-million-connections-with-centrifugo.md",title:"Million connections with Centrifugo",description:"Describing a test stand in Kubernetes where we connect one million websocket connections to a server, using Redis to scale nodes, and providing insights about hardware resources required to achieve 500k messages per second",date:"2020-02-10T00:00:00.000Z",formattedDate:"February 10, 2020",tags:[{label:"centrifuge",permalink:"/blog/tags/centrifuge"},{label:"go",permalink:"/blog/tags/go"}],readingTime:3.045,hasTruncateMarker:!0,authors:[{name:"Centrifugal team",title:"Let the Centrifugal force be with you",imageURL:"/img/logo_animated.svg"}],frontMatter:{title:"Million connections with Centrifugo",tags:["centrifuge","go"],description:"Describing a test stand in Kubernetes where we connect one million websocket connections to a server, using Redis to scale nodes, and providing insights about hardware resources required to achieve 500k messages per second",author:"Centrifugal team",authorTitle:"Let the Centrifugal force be with you",authorImageURL:"/img/logo_animated.svg",image:"/img/million_conns.jpg",hide_table_of_contents:!1},prevItem:{title:"Experimenting with QUIC and WebTransport",permalink:"/blog/2020/10/16/experimenting-with-quic-transport"}},l={authorsImageUrls:[void 0]},c=[],u={toc:c};function m(e){let{components:n,...i}=e;return(0,o.kt)("wrapper",(0,r.Z)({},u,i,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("img",{src:"/img/million_conns.jpg"}),(0,o.kt)("p",null,"In order to get an understanding about possible hardware requirements for reasonably massive Centrifugo setup we made a test stand inside Kubernetes."),(0,o.kt)("p",null,"Our goal was to run server based on Centrifuge library (the core of Centrifugo server) with one million WebSocket connections and send many messages to connected clients. While sending many messages we have been looking at delivery time latency. In fact we will see that about 30 million messages per minute (500k messages per second) will be delivered to connected clients and latency won't be larger than 200ms in 99 percentile."),(0,o.kt)("p",null,"Server nodes have been run on machines with the following configuration:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"CPU Intel(R) Xeon(R) CPU E5-2640 v4 @ 2.40GHz"),(0,o.kt)("li",{parentName:"ul"},"Linux Debian 4.9.65-3+deb9u1 (2017-12-23) x86_64 GNU/Linux ")),(0,o.kt)("p",null,"Some ",(0,o.kt)("inlineCode",{parentName:"p"},"sysctl")," values:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"fs.file-max = 3276750\nfs.nr_open = 1048576\nnet.ipv4.tcp_mem = 3086496  4115330 6172992\nnet.ipv4.tcp_rmem = 8192    8388608 16777216\nnet.ipv4.tcp_wmem = 4096    4194394 16777216\nnet.core.rmem_max = 33554432\nnet.core.wmem_max = 33554432\n")),(0,o.kt)("p",null,"Kubernetes used these machines as its nodes. "),(0,o.kt)("p",null,"We started 20 Centrifuge-based server pods. Our clients connected to server pods using Centrifuge Protobuf protocol. To scale horizontally we used Redis Engine and sharded it to 5 different Redis instances (each Redis instance consumes 1 CPU max)."),(0,o.kt)("p",null,"To achieve many client connections we used 100 Kubernetes pods each generating about 10k client connections to server."),(0,o.kt)("p",null,"Here are some numbers we achieved:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"1 million WebSocket connections"),(0,o.kt)("li",{parentName:"ul"},"Each connection subscribed to 2 channels: one personal channel and one group channel (with 10 subscribers in it), i.e. we had about 1.1 million active channels at each moment."),(0,o.kt)("li",{parentName:"ul"},"28 million messages per minute (about 500k per second) ",(0,o.kt)("strong",{parentName:"li"},"delivered")," to clients"),(0,o.kt)("li",{parentName:"ul"},"200k per minute constant connect/disconnect rate to simulate real-life situation where clients connect/disconnect from server"),(0,o.kt)("li",{parentName:"ul"},"200ms delivery latency in 99 percentile"),(0,o.kt)("li",{parentName:"ul"},"The size of each published message was about 100 bytes")),(0,o.kt)("p",null,"And here are some numbers about final resource usage on server side (we don't actually interested in client side resource usage here):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"40 CPU total for server nodes when load achieved values claimed above (20 pods, ~2 CPU each)"),(0,o.kt)("li",{parentName:"ul"},"27 GB of RAM used mostly to handle 1 mln WebSocket connections, i.e. about 30kb RAM per connection"),(0,o.kt)("li",{parentName:"ul"},"0.32 CPU usage on every Redis instance"),(0,o.kt)("li",{parentName:"ul"},"100 mbit/sec rx \u0438 150 mbit/sec tx of network used on each server pod")),(0,o.kt)("p",null,"The picture that demonstrates experiment (better to open image in new tab):"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Benchmark",src:t(86842).Z,width:"1860",height:"916"})),(0,o.kt)("p",null,"This also demonstrates that to handle one million of WebSocket connections without many messages sent to clients you need about 10 CPU total for server nodes and about 5% of CPU on each of Redis instances. In this case CPU mostly spent on connect/disconnect flow, ping/pong frames, subscriptions to channels."),(0,o.kt)("p",null,"If we enable history and history message recovery features we see an increased Redis CPU usage: 64% instead of 32% on the same workload. Other resources usage is pretty the same."),(0,o.kt)("p",null,"The results mean that one can theoretically achieve the comparable numbers on single modern server machine. But numbers can vary a lot in case of different load scenarios. In this benchmark we looked at basic use case where we only connect many clients and send Publications to them. There are many features in Centrifuge library and in Centrifugo not covered by this artificial experiment. Also note that though benchmark was made for Centrifuge library for Centrifugo you can expect similar results."),(0,o.kt)("p",null,"Read and write buffer sizes of websocket connections were set to 512 kb on server side (sizes of buffers affect memory usage), with Centrifugo this means that to reproduce the same configuration you need to set:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n    ...\n    "websocket_read_buffer_size": 512,\n    "websocket_write_buffer_size": 512\n}\n')))}m.isMDXComponent=!0},86842:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/images/benchmark-b670972866abdc8936d2aef84333dd0c.gif"}}]);