"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[9109],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>u});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var r=i.createContext({}),c=function(e){var n=i.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=c(e.components);return i.createElement(r.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(t),u=a,k=m["".concat(r,".").concat(u)]||m[u]||d[u]||o;return t?i.createElement(k,s(s({ref:n},p),{},{components:t})):i.createElement(k,s({ref:n},p))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=m;var l={};for(var r in n)hasOwnProperty.call(n,r)&&(l[r]=n[r]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var c=2;c<o;c++)s[c]=t[c];return i.createElement.apply(null,s)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},6796:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var i=t(7462),a=(t(7294),t(3905));const o={id:"client_protocol",title:"Client protocol"},s=void 0,l={unversionedId:"transports/client_protocol",id:"version-3/transports/client_protocol",title:"Client protocol",description:"This chapter describes internal bidirectional client-server protocol in details to help developers build new client libraries or understand how existing client connectors work.",source:"@site/versioned_docs/version-3/transports/protocol.md",sourceDirName:"transports",slug:"/transports/client_protocol",permalink:"/docs/3/transports/client_protocol",draft:!1,editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/versioned_docs/version-3/transports/protocol.md",tags:[],version:"3",frontMatter:{id:"client_protocol",title:"Client protocol"},sidebar:"Transports",previous:{title:"SockJS",permalink:"/docs/3/transports/sockjs"},next:{title:"WebSocket",permalink:"/docs/3/transports/uni_websocket"}},r={},c=[{value:"Client implementation feature matrix",id:"client-implementation-feature-matrix",level:3},{value:"Top level framing",id:"top-level-framing",level:3},{value:"Connect",id:"connect",level:3},{value:"Subscribe",id:"subscribe",level:3},{value:"Unsubscribe",id:"unsubscribe",level:3},{value:"Refresh",id:"refresh",level:3},{value:"RPC-like calls: publish, history, presence",id:"rpc-like-calls-publish-history-presence",level:3},{value:"Asynchronous server-to-client messages",id:"asynchronous-server-to-client-messages",level:3},{value:"Ping Pong",id:"ping-pong",level:3},{value:"Handle disconnects",id:"handle-disconnects",level:3},{value:"Handle errors",id:"handle-errors",level:3},{value:"Client implementation advices",id:"client-implementation-advices",level:3},{value:"Server side subscriptions (SSS)",id:"server-side-subscriptions-sss",level:3},{value:"Message recovery",id:"message-recovery",level:3},{value:"Disconnect code and reason",id:"disconnect-code-and-reason",level:3},{value:"Additional notes",id:"additional-notes",level:3}],p={toc:c};function d(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This chapter describes internal bidirectional client-server protocol in details to help developers build new client libraries or understand how existing client connectors work."),(0,a.kt)("p",null,"Note that you can always look at ",(0,a.kt)("a",{parentName:"p",href:"/docs/3/transports/client_sdk"},"existing client implementations")," in case of any questions. Not all clients support all available server features though."),(0,a.kt)("h3",{id:"client-implementation-feature-matrix"},"Client implementation feature matrix"),(0,a.kt)("p",null,"First we will look at list of features bidirectional client library should support. If you are an author of client library you can use this list as a checklist."),(0,a.kt)("p",null,"Our current client feature matrix looks like this:"),(0,a.kt)("ul",{className:"contains-task-list"},(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","connect to server (both Centrifugo and Centrifuge-based) using JSON protocol format"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","connect to server (both Centrifugo and Centrifuge-based) using Protobuf protocol format"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","connect with token (JWT in Centrifugo case, any string token in Centrifuge library case)"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","connect to server with custom headers (not available in a browser)"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","automatic reconnect in case of connection problems (server restart, unavailable network)"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","an exponential backoff for reconnect process"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","possibility to set handlers for connect and disconnect events"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","extract and expose disconnect code and reason"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","subscribe to a channel and provide a way to handle asynchronous Publications coming from it"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","handle Join and Leave messages from a channel"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","handle Unsubscribe notifications"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","provide publish method of Subscription object"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","provide unsubscribe method of Subscription"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","provide presence method of Subscription"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","provide presence stats method of Subscription"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","provide history method of Subscription"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","provide publish method on top level"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","provide unsubscribe method on top level"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","provide presence method on top level"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","provide presence stats method on top level"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","provide history method on top level"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","send asynchronous messages to server"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","handle asynchronous messages from server"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","send RPC requests to server"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","publish to channel without being subscribed"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","subscribe to private (token-protected) channels with a token"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","implement client-side connection token refresh mechanism"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","implement private channel subscription token refresh mechanism"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","client protocol level ping/pong to find a broken connection"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","automatic reconnect in case of connect or subscribe command timeouts"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","handle connection expired error"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","handle subscription expired error"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","server-side subscriptions"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","message recovery mechanism for client-side subscriptions"),(0,a.kt)("li",{parentName:"ul",className:"task-list-item"},(0,a.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","message recovery mechanism for server-side subscriptions")),(0,a.kt)("p",null,"This document describes protocol specifics for Websocket transport which supports binary and text formats to transfer data. As Centrifugo and Centrifuge library for Go have various types of messages it serializes protocol messages using JSON or Protobuf formats."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"SockJS works almost the same way as JSON websocket described here but has its own extra framing on top of Centrifuge protocol messages. SockJS can only work with JSON - it's not possible to transfer binary data over it.")),(0,a.kt)("h3",{id:"top-level-framing"},"Top level framing"),(0,a.kt)("p",null,"Centrifuge protocol defined in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/protocol/blob/master/definitions/client.proto"},"Protobuf schema"),". That schema is a source of the truth. Below we describe messages from that schema."),(0,a.kt)("p",null,"In bidirectional case client sends ",(0,a.kt)("inlineCode",{parentName:"p"},"Command")," to server and server sends ",(0,a.kt)("inlineCode",{parentName:"p"},"Reply")," to client. I.e. all communication between client and server is a bidirectional exchange of ",(0,a.kt)("inlineCode",{parentName:"p"},"Command")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Reply")," messages."),(0,a.kt)("p",null,"One request from client to server and one response from server to client can have more than one ",(0,a.kt)("inlineCode",{parentName:"p"},"Command")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Reply"),". This allows reducing number of system calls for writing and reading data."),(0,a.kt)("p",null,"When JSON format used then many ",(0,a.kt)("inlineCode",{parentName:"p"},"Command")," can be sent from client to server in JSON streaming line-delimited format. I.e. each individual ",(0,a.kt)("inlineCode",{parentName:"p"},"Command")," encoded to JSON and then commands joined together using new line symbol ",(0,a.kt)("inlineCode",{parentName:"p"},"\\n"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},'{"id": 1, "method": 1, "params": {"channel": "ch1"}}\n{"id": 2, "method": 1, "params": {"channel": "ch2"}}\n')),(0,a.kt)("p",null,"For example here is how we do this in Javascript client when JSON format used:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function encodeCommands(commands) {\n    const encodedCommands = [];\n    for (const i in commands) {\n      if (commands.hasOwnProperty(i)) {\n        encodedCommands.push(JSON.stringify(commands[i]));\n      }\n    }\n    return encodedCommands.join('\\n');\n}\n")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"This doc will use JSON format for examples because it's human-readable. Everything said here for JSON is also true for Protobuf encoded case. There is a difference how several individual ",(0,a.kt)("inlineCode",{parentName:"p"},"Command")," or server ",(0,a.kt)("inlineCode",{parentName:"p"},"Reply")," joined into one request \u2013 see details below. Also, in JSON format ",(0,a.kt)("inlineCode",{parentName:"p"},"bytes")," fields transformed into embedded JSON by Centrifugo.")),(0,a.kt)("p",null,"When Protobuf format used then many ",(0,a.kt)("inlineCode",{parentName:"p"},"Command")," can be sent from client to server in length-delimited format where each individual ",(0,a.kt)("inlineCode",{parentName:"p"},"Command")," marshaled to bytes prepended by ",(0,a.kt)("inlineCode",{parentName:"p"},"varint")," length. See existing client implementations for encoding example."),(0,a.kt)("p",null,"The same rules relate to many ",(0,a.kt)("inlineCode",{parentName:"p"},"Reply")," in one response from server to client. Line-delimited JSON and varint-length prefixed Protobuf also used there."),(0,a.kt)("p",null,"For example here is how we read server response and extracting individual replies in Javascript client when JSON format used:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function decodeReplies(data) {\n    const replies = [];\n    const encodedReplies = data.split('\\n');\n    for (const i in encodedReplies) {\n      if (encodedReplies.hasOwnProperty(i)) {\n        if (!encodedReplies[i]) {\n          continue;\n        }\n        const reply = JSON.parse(encodedReplies[i]);\n        replies.push(reply);\n      }\n    }\n    return replies;\n}\n")),(0,a.kt)("p",null,"For Protobuf case see existing client implementations for decoding example."),(0,a.kt)("p",null,"As you can see each ",(0,a.kt)("inlineCode",{parentName:"p"},"Command")," has ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," field. This is an incremental ",(0,a.kt)("inlineCode",{parentName:"p"},"uint32")," field. This field will be echoed in a server replies to commands so client could match a certain ",(0,a.kt)("inlineCode",{parentName:"p"},"Reply")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"Command")," sent before. This is important since Websocket is an asynchronous protocol where server and client both send messages at any moment and there is no builtin request-response matching. Having ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," allows matching a reply with a command send before."),(0,a.kt)("p",null,"So you can expect something like this in response after sending commands to server:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},'{"id": 1, "result": {}}\n{"id": 2, "result": {}}\n')),(0,a.kt)("p",null,"Besides ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," ",(0,a.kt)("inlineCode",{parentName:"p"},"Reply")," from server to client have two important fields: ",(0,a.kt)("inlineCode",{parentName:"p"},"result")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"error"),"."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"result")," contains useful payload object which is different for various ",(0,a.kt)("inlineCode",{parentName:"p"},"Reply")," messages."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"error")," contains error description if ",(0,a.kt)("inlineCode",{parentName:"p"},"Command")," processing resulted in some error on a server. ",(0,a.kt)("inlineCode",{parentName:"p"},"error")," is optional and if ",(0,a.kt)("inlineCode",{parentName:"p"},"Reply")," does not have ",(0,a.kt)("inlineCode",{parentName:"p"},"error")," then it means that ",(0,a.kt)("inlineCode",{parentName:"p"},"Command")," processed successfully and client can parse ",(0,a.kt)("inlineCode",{parentName:"p"},"result")," object appropriately."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"error")," looks like this in JSON case:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "code": 100,\n    "message": "internal server error"\n}\n')),(0,a.kt)("p",null,"We will talk more about error handling below."),(0,a.kt)("p",null,"The special type of ",(0,a.kt)("inlineCode",{parentName:"p"},"Reply")," is ",(0,a.kt)("strong",{parentName:"p"},"asynchronous")," ",(0,a.kt)("inlineCode",{parentName:"p"},"Reply"),". Such replies have no ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," field set (or ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," can be equal to zero). Async replies can come to client in any moment - not as reaction to issued ",(0,a.kt)("inlineCode",{parentName:"p"},"Command")," but as message from server to client in arbitrary time. For example this can be a message published into channel."),(0,a.kt)("p",null,"Centrifuge library defines several command types client can issue. A well-written client must be aware of all those commands and client workflow. Communication with Centrifuge/Centrifugo server starts with issuing ",(0,a.kt)("inlineCode",{parentName:"p"},"connect")," command."),(0,a.kt)("h3",{id:"connect"},"Connect"),(0,a.kt)("p",null,"First of all client must dial with a server and then send ",(0,a.kt)("inlineCode",{parentName:"p"},"connect")," ",(0,a.kt)("inlineCode",{parentName:"p"},"Command")," to it."),(0,a.kt)("p",null,"Default Websocket endpoint in Centrifugo is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"ws://centrifugo.example.com/connection/websocket\n")),(0,a.kt)("p",null,"In case of using TLS:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"wss://centrifugo.example.com/connection/websocket\n")),(0,a.kt)("p",null,"After a successful dial to WebSocket endpoint client must send ",(0,a.kt)("inlineCode",{parentName:"p"},"connect")," command to server to authorize itself."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"connect")," command looks like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id": 1,\n    "method": 0,\n    "params": {\n        "token": "JWT",\n        "data": {}\n    }\n}\n')),(0,a.kt)("p",null,"All methods defined in Protobuf schema:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"message Command {\n  uint32 id = 1;\n  enum MethodType {\n    CONNECT = 0;\n    SUBSCRIBE = 1;\n    UNSUBSCRIBE = 2;\n    PUBLISH = 3;\n    PRESENCE = 4;\n    PRESENCE_STATS = 5;\n    HISTORY = 6;\n    PING = 7;\n    SEND = 8;\n    RPC = 9;\n    REFRESH = 10;\n    SUB_REFRESH = 11;\n  }\n  MethodType method = 2;\n  bytes params = 3;\n}\n")),(0,a.kt)("p",null,"So here we are using a enum value for ",(0,a.kt)("inlineCode",{parentName:"p"},"CONNECT")," (",(0,a.kt)("inlineCode",{parentName:"p"},"0"),")."),(0,a.kt)("p",null,"Params fields:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"optional string ",(0,a.kt)("inlineCode",{parentName:"li"},"token")," - connection token. Can be omitted if token-based auth not used."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"data")," - can contain custom connect data, for example it can contain client settings.")),(0,a.kt)("p",null,"In response to ",(0,a.kt)("inlineCode",{parentName:"p"},"connect")," command server sends a connect reply. It looks this way:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id": 1,\n    "result":{\n        "client": "421bf374-dd01-4f82-9def-8c31697e956f",\n        "version": "2.0.0"\n    }\n}\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"result")," has some fields:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"string ",(0,a.kt)("inlineCode",{parentName:"li"},"client")," - unique client connection ID server issued to this connection"),(0,a.kt)("li",{parentName:"ul"},"string ",(0,a.kt)("inlineCode",{parentName:"li"},"version")," - server version"),(0,a.kt)("li",{parentName:"ul"},"optional bool ",(0,a.kt)("inlineCode",{parentName:"li"},"expires")," - whether a server will expire connection at some point"),(0,a.kt)("li",{parentName:"ul"},"optional int32 ",(0,a.kt)("inlineCode",{parentName:"li"},"ttl")," - time in seconds until connection expires")),(0,a.kt)("h3",{id:"subscribe"},"Subscribe"),(0,a.kt)("p",null,"As soon as client successfully connected and got unique connection ID it is ready to\nsubscribe on channels. To do this it must send ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribe")," command to server:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id": 2,\n    "method": 1,\n    "params": {\n        "channel": "ch1"\n    }\n}\n')),(0,a.kt)("p",null,"Fields that can be set in ",(0,a.kt)("inlineCode",{parentName:"p"},"params")," are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"string ",(0,a.kt)("inlineCode",{parentName:"li"},"channel")," - channel to subscribe")),(0,a.kt)("p",null,"In response to subscribe a client receives reply like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id": 2,\n    "result": {}\n}\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"result")," can have the following fields that relate to subscription expiration:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"optional bool ",(0,a.kt)("inlineCode",{parentName:"li"},"expires")," - indicates whether subscription expires or not."),(0,a.kt)("li",{parentName:"ul"},"optional uint32 ",(0,a.kt)("inlineCode",{parentName:"li"},"ttl")," - number of seconds until subscription expire.")),(0,a.kt)("p",null,"Also several fields that relate to message recovery:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"optional bool ",(0,a.kt)("inlineCode",{parentName:"li"},"recoverable")," - means that messages can be recovered in this subscription."),(0,a.kt)("li",{parentName:"ul"},"optional uint64 ",(0,a.kt)("inlineCode",{parentName:"li"},"offset")," - current publication offset inside channel"),(0,a.kt)("li",{parentName:"ul"},"optional string ",(0,a.kt)("inlineCode",{parentName:"li"},"epoch")," - current epoch inside channel"),(0,a.kt)("li",{parentName:"ul"},"optional array ",(0,a.kt)("inlineCode",{parentName:"li"},"publications")," - this is an array of missed publications in channel. When received client must call general publication event handler for each message in this array."),(0,a.kt)("li",{parentName:"ul"},"optional bool ",(0,a.kt)("inlineCode",{parentName:"li"},"recovered")," - this flag set to ",(0,a.kt)("inlineCode",{parentName:"li"},"true")," when server thinks that all missed publications successfully recovered and send in subscribe reply (in ",(0,a.kt)("inlineCode",{parentName:"li"},"publications")," array) and ",(0,a.kt)("inlineCode",{parentName:"li"},"false")," otherwise.")),(0,a.kt)("p",null,"See more about meaning of recovery related fields in ",(0,a.kt)("a",{parentName:"p",href:"/docs/3/server/history_and_recovery"},"special doc chapter"),"."),(0,a.kt)("p",null,"After a client received a successful reply on ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribe")," command it will receive asynchronous reply messages published to this channel. Messages can be of several types:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Publication")," message"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Join")," message"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Leave")," message"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Unsubscribe")," message")),(0,a.kt)("p",null,"See more about asynchronous messages below. "),(0,a.kt)("h3",{id:"unsubscribe"},"Unsubscribe"),(0,a.kt)("p",null,"When client wants to unsubscribe from a channel and therefore stop receiving asynchronous subscription messages from connection related to channel it must call ",(0,a.kt)("inlineCode",{parentName:"p"},"unsubscribe")," command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id": 3,\n    "method": 2,\n    "params": {\n        "channel": "ch1"\n    }\n}\n')),(0,a.kt)("p",null,"Actually server response does not mean a lot for a client - it must immediately remove channel subscription from internal implementation data structures and ignore all messages related to channel."),(0,a.kt)("h3",{id:"refresh"},"Refresh"),(0,a.kt)("p",null,"It's possible to turn on client connection expiration mechanism on a server. While enabled server will keep track of connections whose time of life is close to the end (connection lifetime set on connection authentication phase). In this case connection will be closed. Client can prevent closing connection refreshing its connection credentials. To do this it must send ",(0,a.kt)("inlineCode",{parentName:"p"},"refresh")," command to server. ",(0,a.kt)("inlineCode",{parentName:"p"},"refresh")," command is similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"connect"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id": 4,\n    "method": 10,\n    "params": {\n        "token": "<refreshed token>"\n    }\n}\n')),(0,a.kt)("p",null,"The tip whether a connection must be refreshed by a client comes in reply to ",(0,a.kt)("inlineCode",{parentName:"p"},"connect")," command shown above - fields ",(0,a.kt)("inlineCode",{parentName:"p"},"expires")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ttl"),"."),(0,a.kt)("p",null,"When client connection expire mechanism is on the value of field ",(0,a.kt)("inlineCode",{parentName:"p"},"expires")," in connect reply is ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),". In this case client implementation should look at ",(0,a.kt)("inlineCode",{parentName:"p"},"ttl")," value which is seconds left until connection will be considered expired. Client must send ",(0,a.kt)("inlineCode",{parentName:"p"},"refresh")," command after this ",(0,a.kt)("inlineCode",{parentName:"p"},"ttl")," seconds. Server gives client a configured window to refresh token after ",(0,a.kt)("inlineCode",{parentName:"p"},"ttl")," passed and then closes connection if client have not updated its token."),(0,a.kt)("p",null,"When connecting with already expired token an error will be returned (with code ",(0,a.kt)("inlineCode",{parentName:"p"},"109"),"). In this case client should refresh its token and reconnect with exponential backoff. "),(0,a.kt)("h3",{id:"rpc-like-calls-publish-history-presence"},"RPC-like calls: publish, history, presence"),(0,a.kt)("p",null,"The mechanics of these calls is simple - client sends command and expects response from server."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"publish")," command allows to publish a message into a channel from a client."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"To publish from client ",(0,a.kt)("inlineCode",{parentName:"p"},"publish")," option in Centrifugo configuration must be set to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"))),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"history")," allows asking a server for channel history if enabled."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"presence")," allows asking a server for channel presence information if enabled."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"presence_stats")," allows asking for short presence info (num clients and unique users in a channel)."),(0,a.kt)("h3",{id:"asynchronous-server-to-client-messages"},"Asynchronous server-to-client messages"),(0,a.kt)("p",null,"There are several types of asynchronous messages that can come from a server to a client. All of them relate to the current client subscriptions."),(0,a.kt)("p",null,"The most important message is ",(0,a.kt)("inlineCode",{parentName:"p"},"Publication"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "result":{\n        "channel":"ch1",\n        "data":{\n            "data":{"input":"1"},\n            "info":{\n                "user":"2694",\n                "client":"5c48510e-cf49-4fa8-a9b2-490b22231e74",\n                "conn_info":{"name":"Alexander"},\n                "chan_info":{}\n            }\n        }\n    }\n}\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Publication")," is a message published into channel. Note that there is no ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," field in this message - this symptom\nallows to distinguish it from ",(0,a.kt)("inlineCode",{parentName:"p"},"Reply")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"Command"),".  "),(0,a.kt)("p",null,"Next message is ",(0,a.kt)("inlineCode",{parentName:"p"},"Join")," message:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "result":{\n        "type":1,\n        "channel":"ch1",\n        "data":{\n            "info":{\n                "user":"2694",\n                "client":"5c48510e-cf49-4fa8-a9b2-490b22231e74",\n                "conn_info":{"name":"Alexander"},\n                "chan_info":{}\n            }\n        }\n    }\n}\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Join")," messages sent when someone joined (subscribed on) channel."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"To enable ",(0,a.kt)("inlineCode",{parentName:"p"},"Join")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Leave")," messages ",(0,a.kt)("inlineCode",{parentName:"p"},"join_leave")," option must be enabled in Centrifugo for a channel namespace.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Leave")," messages sent when someone left (unsubscribed from) channel."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "result":{\n        "type":2,\n        "channel":"ch1",\n        "data":{\n            "info":{\n                "user":"2694",\n                "client":"5c48510e-cf49-4fa8-a9b2-490b22231e74",\n                "conn_info":{"name":"Alexander"},\n                "chan_info":{}\n            }\n        }\n    }\n}\n')),(0,a.kt)("p",null,"Finally ",(0,a.kt)("inlineCode",{parentName:"p"},"Unsubscribe")," message that means that server unsubscribed current client from a channel:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "result":{\n        "type":3,\n        "channel":"ch1",\n        "data":{}\n    }\n}\n')),(0,a.kt)("p",null,"It's possible to distinguish between different types of asynchronous messages looking at ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," field (for ",(0,a.kt)("inlineCode",{parentName:"p"},"Publication")," this field not set or ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),")."),(0,a.kt)("h3",{id:"ping-pong"},"Ping Pong"),(0,a.kt)("p",null,"To maintain connection alive and detect broken connections client must periodically send ",(0,a.kt)("inlineCode",{parentName:"p"},"ping")," commands to server and expect replies to it. Ping command looks like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id":32,\n    "method":"ping"\n}\n')),(0,a.kt)("p",null,"Server just echoes this command back. When client does not receive ping reply for some time it must consider connection broken and try to reconnect. Recommended ping interval is 25 seconds, recommended period to wait for pong is 1-5 seconds. Though those numbers can vary."),(0,a.kt)("h3",{id:"handle-disconnects"},"Handle disconnects"),(0,a.kt)("p",null,"Client should handle disconnect advices from server. In websocket case disconnect advice is sent in reason field of CLOSE Websocket frame. Reason contains string which is ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnect")," object encoded into JSON (even in case of Protobuf scenario). That objects looks like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "reason": "shutdown",\n    "reconnect": true \n}\n')),(0,a.kt)("p",null,"It contains string reason of connection closing and advice to reconnect or not. Client should take this reconnect advice into account."),(0,a.kt)("p",null,"In case of network problems and random disconnect from server without well known reason client should always try to  reconnect with exponential intervals."),(0,a.kt)("h3",{id:"handle-errors"},"Handle errors"),(0,a.kt)("p",null,"This section contains advices to error handling in client implementations."),(0,a.kt)("p",null,"Errors can happen during various operations and can be handled in special way in context of some commands to tolerate network and server problems."),(0,a.kt)("p",null,"Errors during ",(0,a.kt)("inlineCode",{parentName:"p"},"connect")," must result in full client reconnect with exponential backoff strategy. The special case is error with code ",(0,a.kt)("inlineCode",{parentName:"p"},"110")," which signals that connection token already expired. As we said above client should update its connection JWT before connecting to server again.  "),(0,a.kt)("p",null,"Errors during ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribe")," must result in full client reconnect in case of internal error (code ",(0,a.kt)("inlineCode",{parentName:"p"},"100"),"). And be sent to subscribe error event handler of subscription if received error is persistent. Persistent errors are errors like ",(0,a.kt)("inlineCode",{parentName:"p"},"permission denied"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"bad request"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"namespace not found")," etc. Persistent errors in most situation mean a mistake from developers side."),(0,a.kt)("p",null,"The special corner case is client-side timeout during ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribe")," operation. As protocol is asynchronous it's possible in this case that server will eventually subscribe client on channel but client will think that it's not subscribed. It's possible to retry subscription request and tolerate ",(0,a.kt)("inlineCode",{parentName:"p"},"already subscribed")," (code ",(0,a.kt)("inlineCode",{parentName:"p"},"105"),") error as expected. But the simplest solution is to reconnect entirely as this is simpler and gives client a chance to connect to working server instance."),(0,a.kt)("p",null,"Errors during rpc-like operations can be just returned to caller - i.e. user javascript code. Calls like ",(0,a.kt)("inlineCode",{parentName:"p"},"history")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"presence")," are idempotent. You should be accurate with non-idempotent operations like ",(0,a.kt)("inlineCode",{parentName:"p"},"publish")," - in case of client timeout it's possible to send the same message into channel twice if retry publish after timeout - so users of libraries must care about this case \u2013 making sure they have some protection from displaying message twice on client side (maybe some sort of unique key in payload)."),(0,a.kt)("h3",{id:"client-implementation-advices"},"Client implementation advices"),(0,a.kt)("p",null,"Here are some advices about client public API. Examples here are in Javascript language. This is just an attempt to help in developing a client - but rules here is not obligatorily the best way to implement client."),(0,a.kt)("p",null,"Create client instance:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'const centrifuge = new Centrifuge("ws://localhost:8000/connection/websocket", {});\n')),(0,a.kt)("p",null,"Set connection token (in case of using Centrifugo):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'centrifuge.setToken("XXX")\n')),(0,a.kt)("p",null,"Connect to server:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"centrifuge.connect();\n")),(0,a.kt)("p",null,"2 event handlers can be set to ",(0,a.kt)("inlineCode",{parentName:"p"},"centrifuge")," object: ",(0,a.kt)("inlineCode",{parentName:"p"},"connect")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnect")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"centrifuge.on('connect', function(context) {\n    console.log(context);\n});\n\ncentrifuge.on('disconnect', function(context) {\n    console.log(context);\n});\n")),(0,a.kt)("p",null,"Client created in ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnected")," state with ",(0,a.kt)("inlineCode",{parentName:"p"},"reconnect")," attribute set to ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"reconnecting")," flag set to ",(0,a.kt)("inlineCode",{parentName:"p"},"false")," . After ",(0,a.kt)("inlineCode",{parentName:"p"},"connect()")," called state goes to ",(0,a.kt)("inlineCode",{parentName:"p"},"connecting"),". It's only possible to connect from ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnected")," state. Every time ",(0,a.kt)("inlineCode",{parentName:"p"},"connect()")," called ",(0,a.kt)("inlineCode",{parentName:"p"},"reconnect")," flag of client must be set to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),". After each failed connect attempt state must be set to ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnected"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnect")," event must be emitted (only if ",(0,a.kt)("inlineCode",{parentName:"p"},"reconnecting")," flag is ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),"), and then ",(0,a.kt)("inlineCode",{parentName:"p"},"reconnecting")," flag must be set to ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," (if client should continue reconnecting) to not emit ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnect")," event again after next in a row connect attempt failure. In case of failure next connection attempt must be scheduled automatically with backoff strategy. On successful connect ",(0,a.kt)("inlineCode",{parentName:"p"},"reconnecting")," flag must be set to ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),", backoff retry must be reset and ",(0,a.kt)("inlineCode",{parentName:"p"},"connect")," event must be emitted. When connection lost then the same set of actions as when connect failed must be performed."),(0,a.kt)("p",null,"Client must allow to subscribe on channels:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'var subscription = centrifuge.subscribe("channel", eventHandlers);\n')),(0,a.kt)("p",null,"Subscription object created and control immediately returned to caller - subscribing must be performed asynchronously. This is required because client can automatically reconnect later so event-based model better suites for subscriptions. "),(0,a.kt)("p",null,"Subscription should support several event handlers:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"handler for publication received from channel"),(0,a.kt)("li",{parentName:"ul"},"join message handler"),(0,a.kt)("li",{parentName:"ul"},"leave message handler"),(0,a.kt)("li",{parentName:"ul"},"error handler"),(0,a.kt)("li",{parentName:"ul"},"subscribe success event handler"),(0,a.kt)("li",{parentName:"ul"},"unsubscribe event handler")),(0,a.kt)("p",null,"Every time client connects to server it must restore all subscriptions."),(0,a.kt)("p",null,"Every time client disconnects from server it must call unsubscribe handlers for all active subscriptions and then emit disconnect event."),(0,a.kt)("p",null,"Client must periodically (once in 25 secs, configurable) send ping messages to server. If pong has not beed received in 5 secs (configurable) then client must disconnect from server and try to reconnect with backoff strategy."),(0,a.kt)("p",null,"Client can automatically batch several requests into one frame to server and also must be able to handle several replies received from server in one frame."),(0,a.kt)("h3",{id:"server-side-subscriptions-sss"},"Server side subscriptions (SSS)"),(0,a.kt)("p",null,"It's also possible to subscribe connection to channels on server side. In this case we call this server-side subscription. Client should only handle asynchronous messages coming from a server without need to create subscriptions on client side."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"SSS should be kept separate from client-side subs"),(0,a.kt)("li",{parentName:"ul"},"SSS requires new event handlers on top-level of Client - Subscribe, Publish, Join, Leave, Unsubscribe, event handlers will be called with event context similar to client-side subs case but with ",(0,a.kt)("inlineCode",{parentName:"li"},"channel")," field"),(0,a.kt)("li",{parentName:"ul"},"Connect Reply contains SSS set by a server on connect, on reconnect client has a chance to recover missed Publications"),(0,a.kt)("li",{parentName:"ul"},"Server side subscription can happen at any moment - ",(0,a.kt)("inlineCode",{parentName:"li"},"Sub")," Push will be sent to client")),(0,a.kt)("h3",{id:"message-recovery"},"Message recovery"),(0,a.kt)("p",null,"Client should automatically recover messages after being disconnected due to network problems and set appropriate fields in subscribe event context. Two important fields in ",(0,a.kt)("inlineCode",{parentName:"p"},"onSubscribeSuccess")," event context are ",(0,a.kt)("inlineCode",{parentName:"p"},"isRecovered")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"isResubscribe"),". First field let user know what server thinks about subscription state - were all messages recovered or not. The second field must only be true if resubscribe was caused by temporary network connection lost. If user initiated resubscribe himself (calling ",(0,a.kt)("inlineCode",{parentName:"p"},"unsubscribe")," method and then ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribe")," method) then recover workflow should not be used and ",(0,a.kt)("inlineCode",{parentName:"p"},"isResubscribe")," must be ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,a.kt)("h3",{id:"disconnect-code-and-reason"},"Disconnect code and reason"),(0,a.kt)("p",null,"In case of Websocket it is sent by server in CLOSE Websocket frame. This is a string containing JSON object with fields: ",(0,a.kt)("inlineCode",{parentName:"p"},"reason")," (string) and ",(0,a.kt)("inlineCode",{parentName:"p"},"reconnect")," (bool). Client should give users access to these fields in disconnect event and automatically follow ",(0,a.kt)("inlineCode",{parentName:"p"},"reconnect")," advice."),(0,a.kt)("h3",{id:"additional-notes"},"Additional notes"),(0,a.kt)("p",null,"Client protocol does not allow one client connection to subscribe to the same channel twice. In this case client will receive ",(0,a.kt)("inlineCode",{parentName:"p"},"already subscribed")," error in reply to a subscribe command."))}d.isMDXComponent=!0}}]);