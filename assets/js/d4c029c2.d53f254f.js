"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[8973],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var m=o.createContext({}),l=function(e){var t=o.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=l(e.components);return o.createElement(m.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,m=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=l(n),u=a,h=p["".concat(m,".").concat(u)]||p[u]||c[u]||s;return n?o.createElement(h,r(r({ref:t},d),{},{components:n})):o.createElement(h,r({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,r=new Array(s);r[0]=p;var i={};for(var m in t)hasOwnProperty.call(t,m)&&(i[m]=t[m]);i.originalType=e,i.mdxType="string"==typeof e?e:a,r[1]=i;for(var l=2;l<s;l++)r[l]=n[l];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},27077:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var o=n(87462),a=(n(67294),n(3905));const s={id:"frontend",sidebar_label:"Creating SPA frontend",title:"Creating SPA frontend with React"},r=void 0,i={unversionedId:"tutorial/frontend",id:"tutorial/frontend",title:"Creating SPA frontend with React",description:"On the frontend we will use Vite with React and Typescript. In this tutorial we are not paying a lot of attention to making all the types strict and using any a lot. Which is actually a point for improvement, but at least helps to make the tutorial slightly shorter. The prerequisites is NodeJS >= 18.",source:"@site/docs/tutorial/frontend.md",sourceDirName:"tutorial",slug:"/tutorial/frontend",permalink:"/docs/tutorial/frontend",draft:!1,editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/docs/tutorial/frontend.md",tags:[],version:"current",frontMatter:{id:"frontend",sidebar_label:"Creating SPA frontend",title:"Creating SPA frontend with React"},sidebar:"Tutorial",previous:{title:"Adding reverse proxy",permalink:"/docs/tutorial/reverse_proxy"},next:{title:"Integrating Centrifugo",permalink:"/docs/tutorial/centrifugo"}},m={},l=[{value:"App layout",id:"app-layout",level:2},{value:"Login screen",id:"login-screen",level:2},{value:"Chat room list screen",id:"chat-room-list-screen",level:2},{value:"Chat room search screen",id:"chat-room-search-screen",level:2},{value:"Chat room detail screen",id:"chat-room-detail-screen",level:2},{value:"Chat state reducer",id:"chat-state-reducer",level:2},{value:"CLEAR_CHAT_STATE",id:"clear_chat_state",level:3},{value:"ADD_ROOMS",id:"add_rooms",level:3},{value:"DELETE_ROOM",id:"delete_room",level:3},{value:"ADD_MESSAGES",id:"add_messages",level:3},{value:"SET_ROOM_MEMBER_COUNT",id:"set_room_member_count",level:3},{value:"Adding styles",id:"adding-styles",level:2},{value:"What we have at this point",id:"what-we-have-at-this-point",level:2}],d={toc:l};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"On the frontend we will use Vite with React and Typescript. In this tutorial we are not paying a lot of attention to making all the types strict and using ",(0,a.kt)("inlineCode",{parentName:"p"},"any")," a lot. Which is actually a point for improvement, but at least helps to make the tutorial slightly shorter. The prerequisites is NodeJS >= 18."),(0,a.kt)("p",null,"We can start by creating frontend app with Vite inside ",(0,a.kt)("inlineCode",{parentName:"p"},"grand-chat-tutorial")," dir:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npm create vite@latest\n")),(0,a.kt)("p",null,"When asked, call the app ",(0,a.kt)("inlineCode",{parentName:"p"},"frontend"),", select ",(0,a.kt)("inlineCode",{parentName:"p"},"React + Typescript")," template. Then:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"cd frontend\nnpm install\n")),(0,a.kt)("p",null,"Since we want to start the entire application with a single docker compose command \u2013 let's again update ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-compose.yml"),". First, create custom Dockerfile in the frontend folder:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-Dockerfile",metastring:'title="frontend/Dockerfile"',title:'"frontend/Dockerfile"'},'FROM node:18-slim\n\nWORKDIR /usr/src/app\n\nENV PATH /usr/src/app/node_modules/.bin:$PATH\n\n# install and cache app dependencies\nCOPY package.json .\nCOPY package-lock.json .\nRUN npm ci\n\nCMD ["vite", "--host"]\n')),(0,a.kt)("p",null,"And add ",(0,a.kt)("inlineCode",{parentName:"p"},"frontend")," service to ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-compose.yaml")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="docker-compose.yml"',title:'"docker-compose.yml"'},"frontend:\n  stdin_open: true\n  build: ./frontend\n  volumes:\n    - ./frontend:/usr/src/app\n    - /usr/src/app/node_modules\n  expose:\n    - 5173\n  environment:\n    - NODE_ENV=development\n  depends_on:\n    - backend\n")),(0,a.kt)("p",null,"When you eventually run application with docker compose, the frontend will be updated automatically upon changes in source code files \u2013 which is super nice for the development. "),(0,a.kt)("h2",{id:"app-layout"},"App layout"),(0,a.kt)("p",null,"Describing frontend code will be not so linear like we had for the backend case. First, let's start with the application top-level layout:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="frontend/src/App.tsx"',title:'"frontend/src/App.tsx"'},"const App: React.FC = () => {\n  let localAuth: any = {};\n  if (localStorage.getItem(LOCAL_STORAGE_AUTH_KEY)) {\n    localAuth = JSON.parse(localStorage.getItem(LOCAL_STORAGE_AUTH_KEY)!)\n  }\n  const [authenticated, setAuthenticated] = useState<boolean>(localAuth.id !== undefined)\n  const [userInfo, setUserInfo] = useState<any>(localAuth)\n  const [csrf, setCSRF] = useState('')\n  const [unrecoverableError, setUnrecoverableError] = useState('')\n  const [chatState, dispatch] = useReducer(reducer, initialChatState);\n  const [realTimeStatus, setRealTimeStatus] = useState('\ud83d\udd34')\n  const [messageQueue, setMessageQueue] = useState<any[]>([]);\n\n  return (\n    <CsrfContext.Provider value={csrf}>\n      <AuthContext.Provider value={userInfo}>\n        {authenticated ? (\n          <ChatContext.Provider value={{ state: chatState, dispatch }}>\n            <Router>\n              <ChatLayout>\n                <Routes>\n                  <Route path=\"/\" element={<ChatRoomList />} />\n                  <Route path=\"/search\" element={<ChatSearch />} />\n                  <Route path=\"/rooms/:id\" element={<ChatRoomDetail />} />\n                </Routes>\n              </ChatLayout>\n            </Router>\n          </ChatContext.Provider>\n        ) : (\n          <ChatLogin />\n        )}\n      </AuthContext.Provider>\n    </CsrfContext.Provider>\n  );\n};\n\nexport default App;\n")),(0,a.kt)("p",null,"Here we skipped some final code to emphasize the core layout."),(0,a.kt)("p",null,"First thing to note is that we wrapped the app into two React contexts: ",(0,a.kt)("inlineCode",{parentName:"p"},"CsrfContext")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthContext"),". React contexts allow sharing some state without need to pass it over props to children components. ",(0,a.kt)("inlineCode",{parentName:"p"},"CsrfContext")," allows access to CSRF token everywhere in the app, ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthContext")," provides authentication information."),(0,a.kt)("p",null,"We render ",(0,a.kt)("inlineCode",{parentName:"p"},"ChatLogin")," page if user is not authenticated and one of the chat screens if user authenticated. ",(0,a.kt)("a",{parentName:"p",href:"https://reactrouter.com/en/main"},"React Router")," is used for the navigation."),(0,a.kt)("p",null,"Authentication information is stored in ",(0,a.kt)("inlineCode",{parentName:"p"},"LocalStorage")," and we load it from there during the app initial load."),(0,a.kt)("p",null,"Note, that here we are using ",(0,a.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/useReducer"},"React reducer")," to manage chat state. We do this to serialize changes and thus simplify state management \u2013 trust us before we started using the reducer chat state management was a hell. It's not the only approach \u2013 there are other techniques to manage state in complex React apps (like ",(0,a.kt)("a",{parentName:"p",href:"https://react-redux.js.org/"},"Redux"),", etc), but reducer works for us here. The initial chat state looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="frontend/src/App.tsx"',title:'"frontend/src/App.tsx"'},"const initialChatState = {\n  rooms: [],\n  roomsById: {},\n  messagesByRoomId: {}\n};\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"rooms")," is an array with room IDs for room sorting during rendering."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"roomsById")," keeps room objects by id"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"messagesByRoomId")," keeps messages by room id")),(0,a.kt)("p",null,"We are not pretending that the way we show here is the best \u2013 it could be organized differently no doubt."),(0,a.kt)("p",null,"Regarding ",(0,a.kt)("inlineCode",{parentName:"p"},"realTimeStatus")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"messageQueue")," \u2013 those will be later used for real-time features."),(0,a.kt)("h2",{id:"login-screen"},"Login screen"),(0,a.kt)("p",null,"Let's look at ",(0,a.kt)("inlineCode",{parentName:"p"},"ChatLogin")," component. To make it we need to render a login form:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title=" title="frontend/src/ChatLogin.tsx"',title:'"frontend/src/ChatLogin.tsx"'},'import React, { useState, useContext } from \'react\';\nimport logo from \'./assets/centrifugo.svg\'\nimport CsrfContext from \'./CsrfContext\';\nimport { login } from \'./AppApi\';\n\ninterface ChatLoginProps {\n  onSuccess: (userId: string) => void;\n}\n\nconst ChatLogin: React.FC<ChatLoginProps> = ({ onSuccess }) => {\n  const [username, setUsername] = useState(\'\');\n  const [password, setPassword] = useState(\'\');\n  const csrf = useContext(CsrfContext);\n\n  const handleLogin = async () => {\n    try {\n      const resp = await login(csrf, username, password)\n      onSuccess(resp.user.id.toString());\n    } catch (err) {\n      console.error(\'Login failed:\', err);\n    }\n  };\n\n  return (\n    <form id="chat-login" onSubmit={(e) => {\n      e.preventDefault()\n      handleLogin()\n    }}>\n      <div id="chat-login-logo-container">\n        <img src={logo} width="100px" height="100px" />\n      </div>\n      <div className="input-container">\n        <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} placeholder="Username" />\n      </div>\n      <div className="input-container">\n        <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} placeholder="Password" />\n      </div>\n      <div className=\'login-button-container\'>\n        <button>Login</button>\n      </div>\n    </form>\n  );\n};\n\nexport default ChatLogin;\n')),(0,a.kt)("p",null,"This is quite a straightforward component. Note the import from ",(0,a.kt)("inlineCode",{parentName:"p"},"./AppApi")," - we've put all the API methods to a separate file, where we use ",(0,a.kt)("inlineCode",{parentName:"p"},"axios")," HTTP client to communicate with the backend API. For example, ",(0,a.kt)("inlineCode",{parentName:"p"},"login")," call looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="frontend/src/AppApi.tsx"',title:'"frontend/src/AppApi.tsx"'},'import { API_ENDPOINT_BASE } from "./AppSettings";\n\nexport const login = async (csrfToken: string, username: string, password: string) => {\n  const response = await axios.post(`${API_ENDPOINT_BASE}/api/login/`, { username, password }, {\n    headers: {\n      "X-CSRFToken": csrfToken\n    }\n  });\n  return response.data\n}\n')),(0,a.kt)("p",null,"Other API calls look very similar, so we wan't pay attention to them further \u2013 but you can always take a look in source code."),(0,a.kt)("h2",{id:"chat-room-list-screen"},"Chat room list screen"),(0,a.kt)("p",null,"On the root page we show rooms current user is member of. ",(0,a.kt)("inlineCode",{parentName:"p"},"ChatRoomList")," component renders rooms. But note that rooms are managed outside of this component \u2013 it just renders rooms from application chat state."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="frontend/src/ChatRoomList.tsx"',title:'"frontend/src/ChatRoomList.tsx"'},'import { useContext } from \'react\';\nimport { Link } from \'react-router-dom\';\nimport ChatContext from \'./ChatContext\'\n\nconst ChatRoomList = () => {\n  const { state } = useContext(ChatContext);\n\n  return (\n    <div id="chat-rooms">\n      {state.rooms.map((roomId: number) => {\n        const room = state.roomsById[roomId]\n        return <div className="chat-room-block" key={room.id}>\n          <Link to={`/rooms/${room.id}`}>\n            <div className="left-column">\n              <span className="name">{room.name}</span>\n              <span className="message-content">\n                {room.last_message? (\n                  <span>\n                    <span className=\'message-content-author\'>{room.last_message.user.username}:</span>\n                    &nbsp;\n                    {room.last_message.content}\n                  </span>\n                ) : (<></>)}\n              </span>\n            </div>\n            <div className="right-column">\n              <span className="chat-room-member-counter">{room.member_count}&nbsp;<span className="chat-room-member-counter-icon">\ud83d\udc08</span></span>\n            </div>\n          </Link>\n        </div>\n      })}\n    </div>\n  );\n};\n\nexport default ChatRoomList;\n')),(0,a.kt)("p",null,"Note, we iterate over ",(0,a.kt)("inlineCode",{parentName:"p"},"state.rooms")," array which only contains IDs of rooms and is a source of truth for the order of rooms on the screen. To remind: we sort rooms on this screen by ",(0,a.kt)("inlineCode",{parentName:"p"},"bumped_at")," field in the descending order. "),(0,a.kt)("h2",{id:"chat-room-search-screen"},"Chat room search screen"),(0,a.kt)("p",null,"Chat rooms search screen shows list of all rooms in the app available to join. What's important to note here \u2013 as soon as user joins/leaves the room we update chat state by dispatching ",(0,a.kt)("inlineCode",{parentName:"p"},"ADD_ROOMS")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"DELETE_ROOM")," state events. This allows us to synchronize room state \u2013 so that after user joins some room, the room appears on room list screen."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="frontend/src/ChatSearch.tsx"',title:'"frontend/src/ChatSearch.tsx"'},"import { useState, useEffect, useContext } from 'react';\nimport CsrfContext from './CsrfContext';\nimport ChatContext from './ChatContext';\nimport { joinRoom, leaveRoom, searchRooms } from './AppApi';\n\ninterface ChatSearchProps {\n  fetchRoom: (roomId: string) => Promise<void>\n}\n\nconst ChatSearch: React.FC<ChatSearchProps> = ({ fetchRoom }) => {\n  const csrf = useContext(CsrfContext);\n  const { state, dispatch } = useContext(ChatContext);\n  const [rooms, setRooms] = useState<any>([]);\n  const [loading, setLoading] = useState<any>({})\n\n  const setLoadingFlag = (roomId: any, value: boolean) => {\n    setLoading((prev: any) => ({\n      ...prev,\n      [roomId]: value\n    }));\n  };\n\n  const onJoin = async (roomId: any) => {\n    setLoadingFlag(roomId, true)\n    try {\n      await joinRoom(csrf, roomId)\n      const room = await fetchRoom(roomId)\n      dispatch({\n        type: \"ADD_ROOMS\", payload: {\n          rooms: [room]\n        }\n      })\n      setRooms(rooms.map((room: any) => \n        room.id === roomId\n          ? { ...room, is_member: true }\n          : room\n      ))\n    } catch (e) {\n      console.log(e)\n    }\n    setLoadingFlag(roomId, false)\n  };\n\n  const onLeave = async (roomId: any) => {\n    setLoadingFlag(roomId, true)\n    try {\n      await leaveRoom(csrf, roomId)\n      dispatch({\n        type: \"DELETE_ROOM\", payload: {\n          roomId: roomId\n        }\n      })\n      setRooms(rooms.map((room: any) => \n        room.id === roomId\n          ? { ...room, is_member: false }\n          : room\n      ))\n    } catch (e) {\n      console.log(e)\n    }\n    setLoadingFlag(roomId, false)\n  };\n\n  useEffect(() => {\n    const fetchRooms = async () => {\n      const rooms = await searchRooms()\n      setRooms(rooms)\n    };\n    fetchRooms();\n  }, []);\n\n  return (\n    <div id=\"chat-rooms\">\n      {rooms.map((room: any) => {\n        const roomState = state.roomsById[room.id]\n        let isMember: boolean;\n        if (roomState == null) {\n          isMember = false\n        } else if (roomState !== undefined) {\n          isMember = true\n        } else {\n          isMember = room.is_member\n        }\n        return <div className={`chat-room-block ${(isMember) ? 'member' : 'not-member'}`} key={room.id}>\n          <div className='room-search-item'>\n            <span>\n              {room.name}\n            </span>\n            <span className=\"room-actions\">\n              <button disabled={loading[room.id] === true} className={`${(isMember) ? 'member' : 'not-member'} ${(loading[room.id]) ? 'loading' : ''}`} onClick={() => {\n                if (isMember) {\n                  onLeave(room.id)\n                } else {\n                  onJoin(room.id)\n                }\n              }}>\n                {(isMember) ? 'Leave' : 'Join'}\n              </button>\n            </span>\n          </div>\n        </div>\n      })}\n    </div>\n  );\n};\n\nexport default ChatSearch;\n")),(0,a.kt)("h2",{id:"chat-room-detail-screen"},"Chat room detail screen"),(0,a.kt)("p",null,"This screen displays information about the room, renders its messages and provides an input to send new messages."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="frontend/src/CharRoomDetail.tsx"',title:'"frontend/src/CharRoomDetail.tsx"'},"import { useState, useEffect, useContext, useRef, UIEvent } from 'react';\nimport { useParams } from 'react-router-dom';\nimport AuthContext from './AuthContext';\nimport ChatContext from './ChatContext';\n\ninterface ChatRoomDetailProps {\n  fetchRoom: (roomId: string) => Promise<void>\n  fetchMessages: (roomId: string) => Promise<any[]>\n  publishMessage: (roomId: string, content: string) => Promise<boolean>\n}\n\nconst ChatRoomDetail: React.FC<ChatRoomDetailProps> = ({ fetchRoom, fetchMessages, publishMessage }) => {\n  const { id } = useParams() as { id: string };\n  const userInfo = useContext(AuthContext);\n  const { state, dispatch } = useContext(ChatContext);\n  const [content, setContent] = useState('')\n  const [messagesLoading, setMessagesLoading] = useState(false)\n  const [roomLoading, setRoomLoading] = useState(false)\n  const [sendLoading, setSendLoading] = useState(false)\n  const [notFound, setNotFound] = useState(false);\n\n  useEffect(() => {\n    if (messagesLoading) return\n    const init = async () => {\n      setMessagesLoading(true)\n      if (!state.messagesByRoomId[id]) {\n        const messages = await fetchMessages(id)\n        if (messages === null) {\n          setNotFound(true);\n        } else {\n          setNotFound(false);\n          dispatch({\n            type: \"ADD_MESSAGES\", payload: {\n              roomId: id,\n              messages: messages\n            }\n          })\n        }\n      }\n      setMessagesLoading(false)\n    }\n    init()\n  }, [id, state.messagesByRoomId, fetchMessages]);\n\n  useEffect(() => {\n    if (roomLoading) return\n    const init = async () => {\n      setRoomLoading(true)\n      if (!state.roomsById[id]) {\n        const room = await fetchRoom(id)\n        if (room === null) {\n          setNotFound(true);\n        } else {\n          setNotFound(false);\n          dispatch({\n            type: \"ADD_ROOMS\", payload: {\n              rooms: [room],\n            }\n          })\n        }\n      }\n      setRoomLoading(false)\n    }\n    init()\n  }, [id, state.roomsById, fetchRoom]);\n\n  const room = state.roomsById[id] || {};\n  const messages = state.messagesByRoomId[id] || [];\n\n  const messagesEndRef = useRef<any>(null); // Ref for the messages container\n\n  const scrollToBottom = () => {\n    const container = messagesEndRef.current;\n    if (container) {\n      const scrollOptions = {\n        top: container.scrollHeight,\n        behavior: 'auto'\n      };\n      container.scrollTo(scrollOptions);\n    }\n  };\n\n  const getTime = (timeString: string) => {\n    const date = new Date(timeString);\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n    return `${hours}:${minutes}:${seconds}`;\n  }\n\n  const onFormSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    if (sendLoading) {\n      return\n    }\n    setSendLoading(true)\n    try {\n      const message = await publishMessage(id!, content)\n      dispatch({\n        type: \"ADD_MESSAGES\", payload: {\n          roomId: id,\n          messages: [message]\n        }\n      })\n      setContent('')\n    } catch (e) {\n      console.log(e)\n    }\n    setSendLoading(false)\n  }\n\n  const handleScroll = (e: UIEvent<HTMLDivElement>) => {\n    const container = (e.target as HTMLElement);\n    if (!container) return;\n    const threshold = 40; // Pixels from the bottom to be considered 'near bottom'\n    const position = container.scrollTop + container.offsetHeight;\n    const height = container.scrollHeight;\n    setIsAtBottom(position + threshold >= height)\n  };\n\n  const [isAtBottom, setIsAtBottom] = useState(true);\n\n  // Scroll to bottom after layout changes.\n  useEffect(() => {\n    if (isAtBottom) {\n      scrollToBottom();\n    }\n  }, [messages, isAtBottom]); // Dependency on messages ensures it runs after messages are updated.\n\n  return (\n    <div id=\"chat-room\">\n      {notFound ? (\n        <div id=\"room-not-found\">\n          NOT A MEMBER OF THIS ROOM\n        </div>\n      ) : (\n        <>\n          <div id=\"room-description\">\n            <span id=\"room-name\">{room.name}</span>\n            <span id=\"room-member-count\">{room.member_count} <span className='chat-room-member-counter-icon'>\ud83d\udc08</span></span>\n          </div>\n          <div id=\"room-messages\" onScroll={handleScroll} ref={messagesEndRef}>\n            {messages.map((message: any) => (\n              <div key={message.id} className={`room-message ${(userInfo.id == message.user.id) ? 'room-message-mine' : 'room-message-not-mine'}`}>\n                <div className='message-avatar'>\n                  <img src={`https://robohash.org/user${message.user.id}.png?set=set4`} alt=\"\" />\n                </div>\n                <div className='message-bubble'>\n                  <div className='message-meta'>\n                    <div className='message-author'>\n                      {message.user.username}\n                    </div>\n                    <div className='message-time'>\n                      {getTime(message.created_at)}\n                    </div>\n                  </div>\n                  <div className='message-content'>\n                    {message.content}\n                  </div>\n                </div>\n              </div>\n            ))}\n          </div>\n          <div id=\"chat-input-container\" className={`${(sendLoading) ? 'loading' : ''}`}>\n            <form onSubmit={onFormSubmit}>\n              <input type=\"text\" autoComplete=\"off\" value={content} placeholder=\"Enter message...\" onChange={e => setContent(e.currentTarget.value)} required />\n            </form>\n          </div>\n        </>\n      )}\n    </div>\n  );\n};\n\nexport default ChatRoomDetail;\n")),(0,a.kt)("p",null,"Let's discuss some important or non-so-obvious things in the implementation."),(0,a.kt)("p",null,"One interesting thing is how we handle scroll \u2013 if user currently in the end of messages area - then we scroll to the end again after adding a new message. If user scrolls top \u2013 we prevent automatic scrolling on new message \u2013 because user most probably does not want scroll to work at that moment. This is a very common UX decision in messenger apps."),(0,a.kt)("p",null,"For faking avatars we are using cute pictures of cats generated by ",(0,a.kt)("a",{parentName:"p",href:"https://robohash.org/"},"robohash.org"),". Each user gets unique cat picture based on user ID."),(0,a.kt)("p",null,"The core behaviour is straightforward \u2013 we render messages in chat and render an input for sending new messages. As soon as user submits input form \u2013 we call the backend API to create a new message in the room."),(0,a.kt)("p",null,"The thing to note \u2013 again, we use calls to modify state here, ",(0,a.kt)("inlineCode",{parentName:"p"},"ADD_ROOMS")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ADD_MESSAGES"),". We will look at reducer and describe state management shortly."),(0,a.kt)("h2",{id:"chat-state-reducer"},"Chat state reducer"),(0,a.kt)("p",null,"To remind, the initial chat state looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="frontend/src/App.tsx"',title:'"frontend/src/App.tsx"'},"const initialChatState = {\n  rooms: [],\n  roomsById: {},\n  messagesByRoomId: {}\n};\n")),(0,a.kt)("p",null,"In the app we have several reducer actions to modify this state:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CLEAR_CHAT_STATE")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ADD_ROOMS")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"DELETE_ROOM")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ADD_MESSAGES")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"SET_ROOM_MEMBER_COUNT"))),(0,a.kt)("p",null,"State management in React is not very handy to write to be honest. What we've found though while writing this tutorial is that ChatGPT helps a lot with this task. If you describe the desired behavior properly \u2013 ChatGPT answers correctly."),(0,a.kt)("h3",{id:"clear_chat_state"},"CLEAR_CHAT_STATE"),(0,a.kt)("p",null,"Allows dropping the entire chat state, simply returns ",(0,a.kt)("inlineCode",{parentName:"p"},"initialChatState")," const:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function reducer(state: any, action: any) {\n  switch (action.type) {\n    case 'CLEAR_CHAT_STATE': {\n      return initialChatState;\n    }\n")),(0,a.kt)("h3",{id:"add_rooms"},"ADD_ROOMS"),(0,a.kt)("p",null,"Used to add rooms to the state. This may happen when we load rooms for room list screen, when we got an event from a room which is not yet known, also it's called from search screen when user joins some room:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"case 'ADD_ROOMS': {\n  const newRooms = action.payload.rooms;\n\n  // Update roomsById with new rooms, avoiding duplicates.\n  const updatedRoomsById = { ...state.roomsById };\n  newRooms.forEach((room: any) => {\n    if (!updatedRoomsById[room.id]) {\n      updatedRoomsById[room.id] = room;\n    }\n  });\n\n  // Merge new room IDs with existing ones, filtering out duplicates.\n  const mergedRoomIds = [...new Set([...newRooms.map((room: any) => room.id), ...state.rooms])];\n\n  // Sort mergedRoomIds based on bumped_at field in updatedRoomsById.\n  const sortedRoomIds = mergedRoomIds.sort((a, b) => {\n    const roomA = updatedRoomsById[a];\n    const roomB = updatedRoomsById[b];\n    // Compare RFC 3339 date strings directly\n    return roomB.bumped_at.localeCompare(roomA.bumped_at);\n  });\n\n  return {\n    ...state,\n    roomsById: updatedRoomsById,\n    rooms: sortedRoomIds\n  };\n}\n")),(0,a.kt)("h3",{id:"delete_room"},"DELETE_ROOM"),(0,a.kt)("p",null,"This action helps to remove the room from room list screen. Used when current user leaves the room from search screen, or when we received an event that current user left the room \u2013 this help us to sync accross different devices."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"case 'DELETE_ROOM': {\n  const roomId = action.payload.roomId;\n\n  // Set the specified room to null instead of deleting it.\n  const newRoomsById = {\n    ...state.roomsById,\n    [roomId]: null // On delete we set roomId to null. This allows to sync membership state of rooms on ChatSearch screen.\n  };\n\n  // Remove the room from the rooms array.\n  const newRooms = state.rooms.filter((id: any) => id !== roomId);\n\n  // Remove associated messages.\n  const { [roomId]: deletedMessages, ...newMessagesByRoomId } = state.messagesByRoomId;\n\n  return {\n    ...state,\n    roomsById: newRoomsById,\n    rooms: newRooms,\n    messagesByRoomId: newMessagesByRoomId\n  };\n}\n")),(0,a.kt)("h3",{id:"add_messages"},"ADD_MESSAGES"),(0,a.kt)("p",null,"Whenever we send message, got async real-time message, or simply load messages on Chat Detail Screen - we call this action to maintain a proper message list for each known room on room list screen."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"case 'ADD_MESSAGES': {\n  const roomId = action.payload.roomId;\n  const newMessages = action.payload.messages;\n  let currentMessages = state.messagesByRoomId[roomId] || [];\n\n  // Combine current and new messages, then filter out duplicates.\n  const combinedMessages = [...currentMessages, ...newMessages].filter(\n    (message, index, self) =>\n      index === self.findIndex(m => m.id === message.id)\n  );\n\n  // Sort the combined messages by id in ascending order.\n  combinedMessages.sort((a, b) => a.id - b.id);\n\n  // Find the message with the highest ID.\n  const maxMessageId = combinedMessages.length > 0 ? combinedMessages[combinedMessages.length - 1].id : null;\n\n  let needSort = false;\n\n  // Update the roomsById object with the new last_message if necessary.\n  const updatedRoomsById = { ...state.roomsById };\n  if (maxMessageId !== null && updatedRoomsById[roomId] && (!updatedRoomsById[roomId].last_message || maxMessageId > updatedRoomsById[roomId].last_message.id)) {\n    const newLastMessage = combinedMessages.find(message => message.id === maxMessageId);\n    updatedRoomsById[roomId].last_message = newLastMessage;\n    updatedRoomsById[roomId].bumped_at = newLastMessage.room.bumped_at;\n    needSort = true;\n  }\n\n  let updatedRooms = [...state.rooms];\n  if (needSort) {\n      // Sort mergedRoomIds based on bumped_at field in updatedRoomsById.\n      updatedRooms = updatedRooms.sort((a: any, b: any) => {\n        const roomA = updatedRoomsById[a];\n        const roomB = updatedRoomsById[b];\n        // Compare RFC 3339 date strings directly\n        return roomB.bumped_at.localeCompare(roomA.bumped_at);\n      });\n  }\n\n  return {\n    ...state,\n    messagesByRoomId: {\n      ...state.messagesByRoomId,\n      [roomId]: combinedMessages\n    },\n    roomsById: updatedRoomsById,\n    rooms: updatedRooms,\n  };\n}\n")),(0,a.kt)("h3",{id:"set_room_member_count"},"SET_ROOM_MEMBER_COUNT"),(0,a.kt)("p",null,"This reducer is called whenever we are getting events about membership changes \u2013 we will add such events soon when talk about Centrifugo integration."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"case 'SET_ROOM_MEMBER_COUNT': {\n  const { roomId, version, memberCount } = action.payload;\n\n  // Check if the roomId exists in roomsById.\n  if (!state.roomsById[roomId]) {\n    console.error(`Room with ID ${roomId} not found.`);\n    return state;\n  }\n\n  // Check if the version in the event is greater than the version in the room object.\n  if (version <= state.roomsById[roomId].version) {\n    console.error(`Outdated version for room ID ${roomId}.`);\n    return state;\n  }\n\n  // Update the member_count and version of the specified room.\n  const updatedRoom = {\n    ...state.roomsById[roomId],\n    member_count: memberCount,\n    version: version,\n  };\n\n  // Return the new state with the updated roomsById.\n  return {\n    ...state,\n    roomsById: {\n      ...state.roomsById,\n      [roomId]: updatedRoom,\n    },\n  };\n}\n")),(0,a.kt)("h2",{id:"adding-styles"},"Adding styles"),(0,a.kt)("p",null,"For making frontend layout we use flexbox for CSS rules so the app will be fully responsive and look good on different screen sizes. If you are interested to learn more about it: check out ",(0,a.kt)("a",{parentName:"p",href:"https://css-tricks.com/snippets/css/a-guide-to-flexbox/"},"this guide"),". Here we won't pay attention to CSS styles anymore."),(0,a.kt)("h2",{id:"what-we-have-at-this-point"},"What we have at this point"),(0,a.kt)("p",null,"Actually, at this point we have an app which provides messenger functionality. "),(0,a.kt)("p",null,"You can use Django admin web UI to create some rooms and interact with them. Users can join/leave rooms, send messages. But to see new messages in room users need to reload a page. Not a good thing for chat app, right? Counters about number of users in particular room are also not updated until page reload. So finally we are ready to integrate the app with Centrifugo."))}c.isMDXComponent=!0}}]);