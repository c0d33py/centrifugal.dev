"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[7272],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(t),m=a,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||s;return t?o.createElement(h,r(r({ref:n},p),{},{components:t})):o.createElement(h,r({ref:n},p))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,r=new Array(s);r[0]=d;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,r[1]=i;for(var c=2;c<s;c++)r[c]=t[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},50958:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var o=t(87462),a=(t(67294),t(3905));const s={id:"centrifugo",sidebar_label:"Integrating Centrifugo",title:"Integrating Centrifugo for real-time event delivery"},r=void 0,i={unversionedId:"tutorial/centrifugo",id:"tutorial/centrifugo",title:"Integrating Centrifugo for real-time event delivery",description:"It's finally time for the real-time! In some cases you already have an application and when integrating Centrifugo you start from here.",source:"@site/docs/tutorial/centrifugo.md",sourceDirName:"tutorial",slug:"/tutorial/centrifugo",permalink:"/docs/tutorial/centrifugo",draft:!1,editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/docs/tutorial/centrifugo.md",tags:[],version:"current",frontMatter:{id:"centrifugo",sidebar_label:"Integrating Centrifugo",title:"Integrating Centrifugo for real-time event delivery"},sidebar:"Tutorial",previous:{title:"Creating SPA frontend",permalink:"/docs/tutorial/frontend"},next:{title:"Missed messages recovery",permalink:"/docs/tutorial/recovery"}},l={},c=[{value:"Adding Centrifugo connection",id:"adding-centrifugo-connection",level:2},{value:"Adding JWT connection authentication",id:"adding-jwt-connection-authentication",level:2},{value:"Subscribing on personal channel",id:"subscribing-on-personal-channel",level:2},{value:"Publish real-time messages",id:"publish-real-time-messages",level:2},{value:"Handle real-time messages",id:"handle-real-time-messages",level:2},{value:"Handle message added event",id:"handle-message-added-event",level:2},{value:"Handle user joined event",id:"handle-user-joined-event",level:2},{value:"Handle user left event",id:"handle-user-left-event",level:2},{value:"We did it",id:"we-did-it",level:2}],p={toc:c};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"It's finally time for the real-time! In some cases you already have an application and when integrating Centrifugo you start from here."),(0,a.kt)("p",null,"To add Centrifugo let's update ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-compose.yml")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"centrifugo:\n  image: centrifugo/centrifugo:v5.2.0\n  volumes:\n    - ./centrifugo/config.json:/centrifugo/config.json\n  command: centrifugo -c config.json\n  expose:\n    - 8000\n")),(0,a.kt)("p",null,"And put ",(0,a.kt)("inlineCode",{parentName:"p"},"config.json")," to local ",(0,a.kt)("inlineCode",{parentName:"p"},"centrifugo")," directory with the following content:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "log_level": "debug",\n    "allowed_origins": ["http://localhost:9000"],\n    "token_hmac_secret_key": "secret",\n    "api_key": "api_key",\n    "namespaces": [{\n        "name": "personal"\n    }]\n}\n')),(0,a.kt)("p",null,"We will be using ",(0,a.kt)("inlineCode",{parentName:"p"},"personal")," ",(0,a.kt)("a",{parentName:"p",href:"/docs/server/channels#channel-namespaces"},"namespace")," here for user channels. Using separate namespaces for every real-time feature is a recommended approach when working with Centrifugo. Namespace allow splitting channel space and configure behavior separately for different real-time features."),(0,a.kt)("h2",{id:"adding-centrifugo-connection"},"Adding Centrifugo connection"),(0,a.kt)("p",null,"Our next goal is to connect to Centrifugo from the frontend app. We will do this right after user authenticated and chat layout loaded."),(0,a.kt)("p",null,"To add real-time WebSocket connection you need to install ",(0,a.kt)("inlineCode",{parentName:"p"},"centrifuge-js")," - Centrifugo SDK for Javascript."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npm install centrifuge\n")),(0,a.kt)("p",null,"Then import it in ",(0,a.kt)("inlineCode",{parentName:"p"},"App.jsx"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"import {\n  Centrifuge, PublicationContext, SubscriptionStateContext,\n  SubscribedContext, SubscriptionState\n} from 'centrifuge';\n")),(0,a.kt)("p",null,"We also imported some types we will be using in the app."),(0,a.kt)("p",null,"To establish a connection with Centrifugo as soon as user authenticated in the app we can use ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," React hook with the dependency on ",(0,a.kt)("inlineCode",{parentName:"p"},"userInfo"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'useEffect(() => {\n  if (!userInfo.id) {\n    return;\n  }\n\n  let centrifuge: Centrifuge | null = null;\n\n  const init = async () => {\n    centrifuge = new Centrifuge(WS_ENDPOINT, {\n      debug: true\n    })\n    centrifuge.connect()\n  }\n\n  // As soon as we get authenticated user \u2013 init our app.\n  init()\n\n  return () => {\n    if (centrifuge) {\n      console.log("disconnect Centrifuge")\n      centrifuge.disconnect()\n    }\n  }\n}, [userInfo])\n')),(0,a.kt)("p",null,"When user logs out and ",(0,a.kt)("inlineCode",{parentName:"p"},"userInfo.id")," is not set \u2013 the connection to server is closed as we do ",(0,a.kt)("inlineCode",{parentName:"p"},"centrifuge.disconnect()")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," cleanup function."),(0,a.kt)("p",null,"But if you run the code like this \u2013 connection won't be established. That's bad news! But we also have good news - this means that Centrifugo supports secure communication and we need to authenticate connection upon establishing! Let's do this."),(0,a.kt)("h2",{id:"adding-jwt-connection-authentication"},"Adding JWT connection authentication"),(0,a.kt)("p",null,"Change ",(0,a.kt)("inlineCode",{parentName:"p"},"Centrifuge")," constructor to:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"centrifuge = new Centrifuge(WS_ENDPOINT, {\n    getToken: getConnectionToken,\n    debug: true\n})\n")),(0,a.kt)("p",null,"Where ",(0,a.kt)("inlineCode",{parentName:"p"},"getConnectionToken")," is function like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export const getConnectionToken = async () => {\n  const response = await axios.get(`${API_ENDPOINT_BASE}/api/token/connection/`, {})\n  return response.data.token;\n}\n")),(0,a.kt)("p",null,"I.e. it makes request to the backend and receives connection JWT in response. Again \u2013 frontend makes request to the backend to get Centrifugo connection token. Of course we should implement the view on the backend which processes such requests and generates tokens for authenticated users."),(0,a.kt)("p",null,"The token must follow specification described in ",(0,a.kt)("a",{parentName:"p",href:"/docs/server/authentication"},"Client JWT authentication")," chapter. Long story short \u2013 it's just a JWT from ",(0,a.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc7519"},"rfc7519"),", we can use any JWT library to generate it."),(0,a.kt)("p",null,"Let's extend ",(0,a.kt)("inlineCode",{parentName:"p"},"backend/app/views.py")," with this view:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="backend/app/views.py"',title:'"backend/app/views.py"'},"import jwt\n\nfrom django.conf import settings\n\n\ndef get_connection_token(request):\n    if not request.user.is_authenticated:\n        return JsonResponse({'detail': 'unauthorized'}, status=401)\n\n    token_claims = {\n        'sub': str(request.user.pk),\n        'exp': int(time.time()) + 120\n    }\n    token = jwt.encode(token_claims, settings.CENTRIFUGO_TOKEN_SECRET)\n\n    return JsonResponse({'token': token})\n")),(0,a.kt)("p",null,"\u2013 where ",(0,a.kt)("inlineCode",{parentName:"p"},"jwt")," import is a PyJWT library (",(0,a.kt)("inlineCode",{parentName:"p"},"pip install PyJWT"),"). We generate JWT where ",(0,a.kt)("inlineCode",{parentName:"p"},"sub")," claim is set to current user ID and token expires in 2 minutes."),(0,a.kt)("p",null,"Note, we are using ",(0,a.kt)("inlineCode",{parentName:"p"},"settings.CENTRIFUGO_TOKEN_SECRET")," here, we need to include this option to ",(0,a.kt)("inlineCode",{parentName:"p"},"backend/app/settings.py"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="backend/app/settings.py"',title:'"backend/app/settings.py"'},"# CENTRIFUGO_TOKEN_SECRET is used to create connection and subscription JWT.\n# SECURITY WARNING: make it strong, keep it in secret, never send to the frontend!\nCENTRIFUGO_TOKEN_SECRET = 'secret'\n")),(0,a.kt)("p",null,"It must match the value of ",(0,a.kt)("inlineCode",{parentName:"p"},'"token_hmac_secret_key"')," option from Centrifugo configuration."),(0,a.kt)("p",null,"Don't forget to include this view to ",(0,a.kt)("inlineCode",{parentName:"p"},"urls.py")," configuration, and then you can finally connect to Centrifugo from the frontend: upon page load ",(0,a.kt)("inlineCode",{parentName:"p"},"centrifuge-js")," SDK makes request to the backend to load connection token, establishes WebSocket connection with Centrifugo passing connection token. Centrifugo validates token and since secrets match Centrifugo may be sure the token contains valid information about user."),(0,a.kt)("h2",{id:"subscribing-on-personal-channel"},"Subscribing on personal channel"),(0,a.kt)("p",null,"Awesome! Though simply being connecting is not that useful. We want to receive real-time data from Centrifugo. But how Centrifugo will understand how to route published data? Of course due to channel concept. Client can subscribe to channel to receive all messages published to that channel."),(0,a.kt)("p",null,"As mentioned before \u2013 for this sort of app using a single individual channel for each user makes a lot of sense."),(0,a.kt)("p",null,"You can ask \u2013 could we simply subscribe to all room channels current user is member of? It may be a good thing if you know that users won't have too many groups, let's say 10-100 max. Going above this number will make UI less efficient. Consider user who is a member of a thousand of groups \u2013 it will require a very heavyweight initial subscribe request. What if user is member of 10k groups? So moving all the routing complexity to the backend having a single individual channel on the frontend seems a more reasonable approach for our app. And this will also help us to simpify state recovery later. "),(0,a.kt)("p",null,"We already have namespace ",(0,a.kt)("inlineCode",{parentName:"p"},"personal")," configured in Centrifugo \u2013 so let's use it to construct individual channel for each user."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const personalChannel = 'personal:' + userInfo.id\n")),(0,a.kt)("p",null,"So for user with id ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," we will have channel ",(0,a.kt)("inlineCode",{parentName:"p"},"personal:1"),", for user ",(0,a.kt)("inlineCode",{parentName:"p"},"2")," \u2013 ",(0,a.kt)("inlineCode",{parentName:"p"},"personal:2")," \u2013 and so on. Of course in messenger app we do not want one user to be able to subscribe on the channel belonging to another user. So we will use ",(0,a.kt)("a",{parentName:"p",href:"/docs/server/channel_token_auth"},"subscription token auth")," for channels here. It's also a JWT loaded from the backend. But this JWT must additionally include ",(0,a.kt)("inlineCode",{parentName:"p"},"channel")," claim. So in React we can create Subscription object this way:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export const getSubscriptionToken = async (channel: string) => {\n  const response = await axios.get(`${API_ENDPOINT_BASE}/api/token/subscription/`, {\n    params: { channel: channel }\n  });\n  return response.data.token;\n}\n\nconst getPersonalChannelSubscriptionToken = async () => {\n    return getSubscriptionToken(personalChannel)\n}\n\nconst sub = centrifuge.newSubscription(personalChannel, {\n    getToken: getPersonalChannelSubscriptionToken\n})\nsub.on('publication', (ctx: PublicationContext) => {\n    // Used to process incoming channel publications. We will talk about it soon.\n    onPublication(ctx.data)\n})\n\nsub.subscribe()\n")),(0,a.kt)("p",null,"Note that we additionally attach ",(0,a.kt)("inlineCode",{parentName:"p"},"channel")," URL query param when requesting backend \u2013 so the backend understands which channel to generate subscription JWT for."),(0,a.kt)("p",null,"On the backend side we check permission to subscribe and return subscription token:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="backend/app/views.py"',title:'"backend/app/views.py"'},"def get_subscription_token(request):\n    if not request.user.is_authenticated:\n        return JsonResponse({'detail': 'unauthorized'}, status=401)\n\n    channel = request.GET.get('channel')\n    if channel != f'personal:{request.user.pk}':\n        return JsonResponse({'detail': 'permission denied'}, status=403)\n\n    token_claims = {\n        'sub': str(request.user.pk),\n        'exp': int(time.time()) + 300,\n        'channel': channel\n    }\n    token = jwt.encode(token_claims, settings.CENTRIFUGO_TOKEN_SECRET)\n\n    return JsonResponse({'token': token})\n")),(0,a.kt)("p",null,"Please refer to ",(0,a.kt)("a",{parentName:"p",href:"/docs/transports/client_api#subscription-token"},"client SDK spec")," for more information about error handling scenarios."),(0,a.kt)("p",null,"Let's also finish up the logic with real-time subscription status now:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"sub.on('state', (ctx: SubscriptionStateContext) => {\n  if (ctx.newState == SubscriptionState.Subscribed) {\n    setRealTimeStatus('\ud83d\udfe2')\n  } else {\n    setRealTimeStatus('\ud83d\udd34')\n  }\n})\n")),(0,a.kt)("p",null,"There are several subscription states in all our SDKs - ",(0,a.kt)("inlineCode",{parentName:"p"},"unsubscribed"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribing"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribed"),". You can also listen for them separately for more granular logic and get more detailed information about the reason of subscription loss. See ",(0,a.kt)("a",{parentName:"p",href:"/docs/transports/client_api"},"client SDK spec")," for more detailed description."),(0,a.kt)("p",null,"Now we should be able to connect (and authenticate) and subscribe to channel (with authorization). Try to open browser tools network tab and see WebSocket frames exchanged between client and server (we showed how to see this in ",(0,a.kt)("a",{parentName:"p",href:"/docs/getting-started/quickstart"},"quickstart"),")."),(0,a.kt)("h2",{id:"publish-real-time-messages"},"Publish real-time messages"),(0,a.kt)("p",null,"Now we have real-time WebSocket connection which is subscribed to user individual channel. It's time to start publishing messages upon changes in chat rooms. In out case, we send a real-time message in one of the following scenarios:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"someone sends a message to a chat room"),(0,a.kt)("li",{parentName:"ul"},"user joins a room"),(0,a.kt)("li",{parentName:"ul"},"user leaves a room")),(0,a.kt)("p",null,"But we want all chat room members to receive events. If user ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," sends a messages to chat room, we need to find all current members of this room and publish real-time message to each personal channel. I.e. if three users with IDs ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"2")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"3")," are members of some room \u2013 then we need to publish message to three channels ",(0,a.kt)("inlineCode",{parentName:"p"},"personal:1"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"personal:2")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"personal:3"),". So all the members will be notified about event in real-time."),(0,a.kt)("p",null,"To efficiently publish message to many channels Centrifugo provides ",(0,a.kt)("a",{parentName:"p",href:"/docs/server/server_api#broadcast"},"broadcast")," API. Let's use HTTP API of Centrifugo:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="backend/chat/views.py"',title:'"backend/chat/views.py"'},"import requests\n\nfrom django.conf import settings\n\n\nclass CentrifugoMixin:\n    # A helper method to return the list of channels for all current members of specific room.\n    # So that the change in the room may be broadcasted to all the members.\n    def get_room_member_channels(self, room_id):\n        members = RoomMember.objects.filter(room_id=room_id).values_list('user', flat=True)\n        return [f'personal:{user_id}' for user_id in members]\n\n    def broadcast_room(self, room_id, broadcast_payload):\n        # Using Centrifugo HTTP API is the simplest way to send real-time message, and usually\n        # it provides the best latency. The trade-off here is that error here may result in\n        # lost real-time event. Depending on the application requirements this may be fine or not.  \n        def broadcast():\n            session = requests.Session()\n            retries = Retry(total=1, backoff_factor=1, status_forcelist=[500, 502, 503, 504])\n            session.mount('http://', HTTPAdapter(max_retries=retries))\n            try:\n                session.post(\n                    \"http://centrifugo:8000/api/broadcast\",\n                    data=json.dumps(broadcast_payload),\n                    headers={\n                        'Content-type': 'application/json', \n                        'X-API-Key': settings.CENTRIFUGO_HTTP_API_KEY,\n                        'X-Centrifugo-Error-Mode': 'transport'\n                    }\n                )\n            except requests.exceptions.RequestException as e:\n                logging.error(e)\n\n        # We need to use on_commit here to not send notification to Centrifugo before\n        # changes applied to the database. Since we are inside transaction.atomic block\n        # broadcast will happen only after successful transaction commit.\n        transaction.on_commit(broadcast)\n\n\nclass MessageListCreateAPIView(ListCreateAPIView, CentrifugoMixin):\n    # Same as before\n\n    @transaction.atomic\n    def create(self, request, *args, **kwargs):\n        room_id = self.kwargs['room_id']\n        room = Room.objects.select_for_update().get(id=room_id)\n        room.increment_version()\n        channels = self.get_room_member_channels(room_id)\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        obj = serializer.save(room=room, user=request.user)\n        room.last_message = obj\n        room.save()\n\n        # This is where we add code to broadcast over Centrifugo API.\n        broadcast_payload = {\n            'channels': channels,\n            'data': {\n                'type': 'message_added',\n                'body': serializer.data\n            },\n            'idempotency_key': f'message_{serializer.data[\"id\"]}'\n        }\n        self.broadcast_room(room_id, broadcast_payload)\n        \n        headers = self.get_success_headers(serializer.data)\n        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\n")),(0,a.kt)("p",null,"Let's mention some important things."),(0,a.kt)("p",null,"We do broadcasts only after successful commit, using Django's ",(0,a.kt)("inlineCode",{parentName:"p"},"transaction.on_commit")," hook. Otherwise transaction we could get an error on transaction commit - but send misleading real-time message."),(0,a.kt)("p",null,"Here we use ",(0,a.kt)("inlineCode",{parentName:"p"},"requests")," library for making HTTP requests (",(0,a.kt)("inlineCode",{parentName:"p"},"pip install requests"),") and do some retries which is nice to deal with temporary network issues."),(0,a.kt)("p",null,"We construct list of channels using ",(0,a.kt)("inlineCode",{parentName:"p"},"values_list")," method of Djanfo queryset to make query more efficient."),(0,a.kt)("p",null,"We also using ",(0,a.kt)("inlineCode",{parentName:"p"},"settings.CENTRIFUGO_HTTP_API_KEY")," which is set in ",(0,a.kt)("inlineCode",{parentName:"p"},"settings.py")," and matches ",(0,a.kt)("inlineCode",{parentName:"p"},"api_key")," option from Centrifugo configuration file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"# CENTRIFUGO_HTTP_API_KEY is used for auth in Centrifugo server HTTP API.\n# SECURITY WARNING: make it strong, keep it in secret!\nCENTRIFUGO_HTTP_API_KEY = 'api_key'\n")),(0,a.kt)("p",null,"Note the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"'idempotency_key': f'message_{serializer.data[\"id\"]}'\n")),(0,a.kt)("p",null,"When publishing we provide ",(0,a.kt)("inlineCode",{parentName:"p"},"idempotency_key")," to Centrifugo \u2013 this allows effectively dropping duplicate publications during configurable time window on Centrifugo side."),(0,a.kt)("p",null,"Another important thing is how we designed the data of the real-time event \u2013 note we've included event ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," field on top level. In this case ",(0,a.kt)("inlineCode",{parentName:"p"},"message_added"),". This approach allows easily expanding possible event types \u2013 so the frontend may distinguish between them and process accordingly."),(0,a.kt)("p",null,"We can extend ",(0,a.kt)("inlineCode",{parentName:"p"},"JoinRoomView")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"LeaveRoomView")," with similar code to also broadcast room membership events:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="backend/chat/views.py"',title:'"backend/chat/views.py"'},"class JoinRoomView(APIView, CentrifugoMixin):\n    # Some code skipped here ....\n\n    @transaction.atomic\n    def post(self, request, room_id):\n        # Some code skipped here ....\n        obj, _ = RoomMember.objects.get_or_create(user=request.user, room=room)\n        channels = self.get_room_member_channels(room_id)\n        obj.room.member_count = len(channels)\n        body = RoomMemberSerializer(obj).data\n\n        broadcast_payload = {\n            'channels': channels,\n            'data': {\n                'type': 'user_joined',\n                'body': body\n            },\n            'idempotency_key': f'user_joined_{obj.pk}'\n        }\n        self.broadcast_room(room_id, broadcast_payload)\n        return Response(body, status=status.HTTP_200_OK)\n\n\nclass LeaveRoomView(APIView, CentrifugoMixin):\n    # Some code skipped here ....\n\n    @transaction.atomic\n    def post(self, request, room_id):\n        # Some code skipped here ....\n        obj = get_object_or_404(RoomMember, user=request.user, room=room)\n        obj.room.member_count = len(channels) - 1\n        pk = obj.pk\n        obj.delete()\n        body = RoomMemberSerializer(obj).data\n\n        broadcast_payload = {\n            'channels': channels,\n            'data': {\n                'type': 'user_left',\n                'body': body\n            },\n            'idempotency_key': f'user_left_{pk}'\n        }\n        self.broadcast_room(room_id, broadcast_payload)\n        return Response(body, status=status.HTTP_200_OK)\n\n")),(0,a.kt)("p",null,"We also would like to mention the concept of room ",(0,a.kt)("inlineCode",{parentName:"p"},"version"),'. Each room has version field in our app, we increment it by one every time we make some room updates. We then attach version to every event we publish. This technique may be useful to avoid processing non-actual real-time messages on the client side. This is especially useful if we use outbox or CDC techniques where delivery latency increases and a chance to get real-time message which is not actual (i.e. app already loaded more "fresh" state from the backend) increases. '),(0,a.kt)("h2",{id:"handle-real-time-messages"},"Handle real-time messages"),(0,a.kt)("p",null,"As we already shown above the entrypoint for incoming real-time messages on the frontend side is ",(0,a.kt)("inlineCode",{parentName:"p"},"on('publication')")," callback of Subscription object."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"sub.on('publication', (ctx: PublicationContext) => {\n    onPublication(ctx.data)\n})\n")),(0,a.kt)("p",null,"Where ",(0,a.kt)("inlineCode",{parentName:"p"},"onPublication")," is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const onPublication = (publication: any) => {\n  setMessageQueue(prevQueue => [...prevQueue, publication]);\n};\n")),(0,a.kt)("p",null,"In our app example we process the messages using asynchronous queue. To be honest, it's hard to give the universal receipt here \u2013 it seems to be a good approach for our example, but probably in your own app you will organise message processing differently."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const [chatState, dispatch] = useReducer(reducer, initialChatState);\nconst [messageQueue, setMessageQueue] = useState<any[]>([]);\n\nuseEffect(() => {\n  if (messageQueue.length === 0) {\n    return; // Return if no messages to process.\n  }\n\n  const processUserJoined = async (body: any) => {\n    // We will describe this very soon.\n  }\n\n  const processUserLeft = async (body: any) => {\n    // We will describe this very soon.\n  }\n\n  const processMessageAdded = async (body: any) => {\n    // We will describe this very soon.\n  };\n\n  const processMessage = async () => {\n    const message = messageQueue[0];\n\n    const { type, body } = message\n    switch (type) {\n      case 'message_added': {\n        await processMessageAdded(body);\n        break\n      }\n      case 'user_joined': {\n        await processUserJoined(body);\n        break\n      }\n      case 'user_left': {\n        await processUserLeft(body);\n        break\n      }\n      default:\n        console.log('unsupported message type', type, body)\n    }\n\n    // Remove the processed message from the queue\n    setMessageQueue(prevQueue => prevQueue.slice(1));\n  };\n\n  processMessage();\n}, [messageQueue, chatState]);\n")),(0,a.kt)("h2",{id:"handle-message-added-event"},"Handle message added event"),(0,a.kt)("p",null,"Let's look what's going on inside ",(0,a.kt)("inlineCode",{parentName:"p"},"processMessageAdded")," function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'const processMessageAdded = async (body: any) => {\n  const roomId = body.room.id\n  const newMessage = body\n\n  let room = chatState.roomsById[roomId]\n  if (!room) {\n    room = await fetchRoom(roomId)\n    dispatch({\n      type: "ADD_ROOMS", payload: {\n        rooms: [room]\n      }\n    })\n  }\n\n  let messages = chatState.messagesByRoomId[roomId]\n  if (!messages) {\n    const messages = await fetchMessages(roomId)\n    dispatch({\n      type: "ADD_MESSAGES", payload: {\n        roomId: roomId,\n        messages: messages\n      }\n    })\n    return;\n  }\n\n  dispatch({\n    type: "ADD_MESSAGES", payload: {\n      roomId: roomId,\n      messages: [newMessage]\n    }\n  })\n}\n')),(0,a.kt)("p",null,"We load the room if it was not loaded yet, load room's messages if it's first time we see a message in the room. "),(0,a.kt)("h2",{id:"handle-user-joined-event"},"Handle user joined event"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'const processUserJoined = async (body: any) => {\n  const roomId = body.room.id\n  const roomVersion = body.room.version\n  let room = chatState.roomsById[roomId]\n  if (!room) {\n    room = await fetchRoom(roomId)\n    if (room === null) {\n      return\n    }\n    dispatch({\n      type: "ADD_ROOMS", payload: {\n        rooms: [room]\n      }\n    })\n  } else {\n    dispatch({\n      type: "SET_ROOM_MEMBER_COUNT", payload: {\n        roomId: roomId,\n        version: roomVersion,\n        memberCount: body.room.member_count\n      }\n    })\n  }\n}\n')),(0,a.kt)("h2",{id:"handle-user-left-event"},"Handle user left event"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'const processUserLeft = async (body: any) => {\n  const roomId = body.room.id\n  const roomVersion = body.room.version\n  const leftUserId = body.user.id\n  let room = chatState.roomsById[roomId]\n  if (room) {\n    if (room.version >= roomVersion) {\n      console.error(`Outdated version for room ID ${roomId}.`);\n      return\n    }\n    if (userInfo.id == leftUserId) {\n      dispatch({\n        type: "DELETE_ROOM", payload: {\n          roomId: roomId\n        }\n      })\n    } else {\n      dispatch({\n        type: "SET_ROOM_MEMBER_COUNT", payload: {\n          roomId: roomId,\n          version: roomVersion,\n          memberCount: body.room.member_count\n        }\n      })\n    }\n  } else if (userInfo.id != leftUserId) {\n    room = await fetchRoom(roomId)\n    dispatch({\n      type: "ADD_ROOMS", payload: {\n        rooms: [room]\n      }\n    })\n  }\n}\n')),(0,a.kt)("h2",{id:"we-did-it"},"We did it"),(0,a.kt)("p",null,"Awesome \u2013 we now have an application with real-time features powered by Centrifugo! Messages and room membership changes are now delivered to users in real-time. Though, it's not the end of our journey. So please, take a break \u2013 and then proceed to the next part."),(0,a.kt)("div",{className:"logo-video"},(0,a.kt)("video",{width:"100%",loop:!0,autoPlay:"autoplay",muted:!0,controls:"",src:"/img/logo.mp4"})))}u.isMDXComponent=!0}}]);