"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[1994],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),h=c(n),m=i,d=h["".concat(l,".").concat(m)]||h[m]||p[m]||o;return n?a.createElement(d,s(s({ref:t},u),{},{components:n})):a.createElement(d,s({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5475:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const o={title:"Centrifuge \u2013 real-time messaging with Go",tags:["centrifuge","go"],author:"Alexander Emelin",authorTitle:"Creator of Centrifugo",authorImageURL:"https://github.com/FZambia.png",description:"An introduction to Centrifuge \u2013 real-time messaging with Go",image:"https://i.imgur.com/W1PeoJL.jpg",hide_table_of_contents:!1},s=void 0,r={permalink:"/blog/2021/01/15/centrifuge-intro",editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/blog/2021-01-15-centrifuge-intro.md",source:"@site/blog/2021-01-15-centrifuge-intro.md",title:"Centrifuge \u2013 real-time messaging with Go",description:"An introduction to Centrifuge \u2013 real-time messaging with Go",date:"2021-01-15T00:00:00.000Z",formattedDate:"January 15, 2021",tags:[{label:"centrifuge",permalink:"/blog/tags/centrifuge"},{label:"go",permalink:"/blog/tags/go"}],readingTime:22.93,hasTruncateMarker:!0,authors:[{name:"Alexander Emelin",title:"Creator of Centrifugo",imageURL:"https://github.com/FZambia.png"}],frontMatter:{title:"Centrifuge \u2013 real-time messaging with Go",tags:["centrifuge","go"],author:"Alexander Emelin",authorTitle:"Creator of Centrifugo",authorImageURL:"https://github.com/FZambia.png",description:"An introduction to Centrifuge \u2013 real-time messaging with Go",image:"https://i.imgur.com/W1PeoJL.jpg",hide_table_of_contents:!1},prevItem:{title:"Centrifugo v3 released",permalink:"/blog/2021/08/31/hello-centrifugo-v3"},nextItem:{title:"Scaling WebSocket in Go and beyond",permalink:"/blog/2020/11/12/scaling-websocket"}},l={authorsImageUrls:[void 0]},c=[{value:"How it&#39;s all started",id:"how-its-all-started",level:2},{value:"So what is Centrifuge?",id:"so-what-is-centrifuge",level:2},{value:"Centrifuge Node",id:"centrifuge-node",level:2},{value:"Authentication",id:"authentication",level:2},{value:"Channel subscriptions",id:"channel-subscriptions",level:2},{value:"Async message passing",id:"async-message-passing",level:2},{value:"RPC",id:"rpc",level:2},{value:"Server-side subscriptions",id:"server-side-subscriptions",level:2},{value:"Windowed history in channel",id:"windowed-history-in-channel",level:2},{value:"Online presence and presence stats",id:"online-presence-and-presence-stats",level:2},{value:"Scalability aspects",id:"scalability-aspects",level:2},{value:"Order and delivery properties",id:"order-and-delivery-properties",level:2},{value:"Ecosystem",id:"ecosystem",level:2},{value:"Performance",id:"performance",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Examples",id:"examples",level:2},{value:"Conclusion",id:"conclusion",level:2}],u={toc:c};function p(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/W1PeoJL.jpg",alt:"Centrifuge"})),(0,i.kt)("p",null,"In this post I'll try to introduce ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/centrifuge"},"Centrifuge")," - the heart of Centrifugo."),(0,i.kt)("p",null,"Centrifuge is a real-time messaging library for the Go language."),(0,i.kt)("p",null,"This post is going to be pretty long (looks like I am a huge fan of long reads) \u2013 so make sure you also have a drink (probably two) and let's go!"),(0,i.kt)("h2",{id:"how-its-all-started"},"How it's all started"),(0,i.kt)("p",null,"I wrote several blog posts before (",(0,i.kt)("a",{parentName:"p",href:"https://medium.com/@fzambia/four-years-in-centrifuge-ce7a94e8b1a8"},"for example this one")," \u2013 yep, it's on Medium...) about an original motivation of ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/centrifugo"},"Centrifugo")," server."),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},"Centrifugo server is not the same as Centrifuge library for Go. It's a full-featured project built on top of Centrifuge library. Naming can be confusing, but it's not too hard once you spend some time with ecosystem.")),(0,i.kt)("p",null,"In short \u2013 Centrifugo was implemented to help traditional web frameworks dealing with many persistent connections (like WebSocket or SockJS HTTP transports). So frameworks like Django or Ruby on Rails, or frameworks from the PHP world could be used on a backend but still provide real-time messaging features like chats, multiplayer browser games, etc for users. With a little help from Centrifugo."),(0,i.kt)("p",null,"Now there are cases when Centrifugo server used in conjunction even with a backend written in Go. While Go mostly has no problems dealing with many concurrent connections \u2013 Centrifugo provides some features beyond simple message passing between a client and a server. That makes it useful, especially since design is pretty non-obtrusive and fits well microservices world. Centrifugo is used in some well-known projects (like ManyChat, Yoola.io, Spot.im, Badoo etc)."),(0,i.kt)("p",null,"At the end of 2018, I released Centrifugo v2 based on a real-time messaging library for Go language \u2013 Centrifuge \u2013 the subject of this post."),(0,i.kt)("p",null,"It was a pretty hard experience to decouple Centrifuge out of the monolithic Centrifugo server \u2013 I was unable to make all the things right immediately, so Centrifuge library API went through several iterations where I introduced backward-incompatible changes. All those changes targeted to make Centrifuge a more generic tool and remove opinionated or limiting parts."),(0,i.kt)("h2",{id:"so-what-is-centrifuge"},"So what is Centrifuge?"),(0,i.kt)("p",null,"This is ... well, a framework to build real-time messaging applications with Go language. If you ever heard about ",(0,i.kt)("a",{parentName:"p",href:"https://socket.io"},"socket.io")," \u2013 then you can think about Centrifuge as an analogue. I think the most popular applications these days are chats of different forms, but I want to emphasize that Centrifuge is not a framework to build chats \u2013 it's a generic instrument that can be used to create different sorts of real-time applications \u2013 real-time charts, multiplayer games."),(0,i.kt)("p",null,"The obvious choice for real-time messaging transport to achieve fast and cross-platform bidirectional communication these days is WebSocket. Especially if you are targeting a browser environment. You mostly don't need to use WebSocket HTTP polyfills in 2021 (though there are still corner cases so Centrifuge supports ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/sockjs/sockjs-client"},"SockJS")," polyfill)."),(0,i.kt)("p",null,"Centrifuge has its own custom protocol on top of plain WebSocket or SockJS frames. "),(0,i.kt)("p",null,"The reason why Centrifuge has its own protocol on top of underlying transport is that it provides several useful primitives to build real-time applications. The protocol ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/protocol/blob/master/definitions/client.proto"},"described as strict Protobuf schema"),". It's possible to pass JSON or binary Protobuf-encoded data over the wire with Centrifuge."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"GRPC is very handy these days too (and can be used in a browser with a help of additional proxies), some developers prefer using it for real-time messaging apps \u2013 especially when one-way communication needed. It can be a bit better from integration perspective but more resource-consuming on server side and a bit trickier to deploy.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Take a look at ",(0,i.kt)("a",{parentName:"p",href:"https://w3c.github.io/webtransport/"},"WebTransport")," \u2013 a brand-new spec for web browsers to allow fast communication between a client and a server on top of QUIC \u2013 it may be a good alternative to WebSocket in the future. This in a draft status at the moment, but it's ",(0,i.kt)("a",{parentName:"p",href:"https://centrifugal.github.io/centrifugo/blog/quic_web_transport/"},"already possible to play with in Chrome"),".")),(0,i.kt)("p",null,"Own protocol is one of the things that prove the framework status of Centrifuge. This dictates certain limits (for example, you can't just use an alternative message encoding) and makes developers use custom client connectors on a front-end side to communicate with a Centrifuge-based server (see more about connectors in ecosystem part)."),(0,i.kt)("p",null,"But protocol solves many practical tasks \u2013 and here we are going to look at real-time features it provides for a developer."),(0,i.kt)("h2",{id:"centrifuge-node"},"Centrifuge Node"),(0,i.kt)("p",null,"To start working with Centrifuge you need to start Centrifuge server Node. Node is a core of Centrifuge \u2013 it has many useful methods \u2013 set event handlers, publish messages to channels, etc. We will look at some events and channels concept very soon."),(0,i.kt)("p",null,"Also, Node abstracts away scalability aspects, so you don't need to think about how to scale WebSocket connections over different server instances and still have a way to deliver published messages to interested clients."),(0,i.kt)("p",null,"For now, let's start a single instance of Node that will serve connections for us:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"node, err := centrifuge.New(centrifuge.DefaultConfig)\nif err != nil {\n    log.Fatal(err)\n}\n\nif err := node.Run(); err != nil {\n    log.Fatal(err)\n}\n")),(0,i.kt)("p",null,"It's also required to serve a WebSocket handler \u2013 this is possible just by registering ",(0,i.kt)("inlineCode",{parentName:"p"},"centrifuge.WebsocketHandler")," in HTTP mux:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'wsHandler := centrifuge.NewWebsocketHandler(node, centrifuge.WebsocketConfig{})\nhttp.Handle("/connection/websocket", wsHandler)\n')),(0,i.kt)("p",null,"Now it's possible to connect to a server (using Centrifuge connector for a browser called ",(0,i.kt)("inlineCode",{parentName:"p"},"centrifuge-js"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const centrifuge = new Centrifuge('ws://localhost:8000/connection/websocket');\ncentrifuge.connect();\n")),(0,i.kt)("p",null,"Though connection will be rejected by the server since we also need to provide authentication details \u2013 Centrifuge expects explicitly provided connection ",(0,i.kt)("inlineCode",{parentName:"p"},"Credentials")," to accept connection."),(0,i.kt)("h2",{id:"authentication"},"Authentication"),(0,i.kt)("p",null,"Let's look at how we can tell Centrifuge details about connected user identity, so it could accept an incoming connection."),(0,i.kt)("p",null,"There are two main ways to authenticate client connection in Centrifuge."),(0,i.kt)("p",null,"The first one is over the native middleware mechanism. It's possible to wrap ",(0,i.kt)("inlineCode",{parentName:"p"},"centrifuge.WebsocketHandler")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"centrifuge.SockjsHandler")," with middleware that checks user authentication and tells Centrifuge current user ID over ",(0,i.kt)("inlineCode",{parentName:"p"},"context.Context"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'func auth(h http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        cred := &centrifuge.Credentials{\n            UserID: "42",\n        }\n        newCtx := centrifuge.SetCredentials(r.Context(), cred)\n        r = r.WithContext(newCtx)\n        h.ServeHTTP(w, r)\n    })\n}\n')),(0,i.kt)("p",null,"So WebsocketHandler can be registered this way (note that a handler now wrapped by auth middleware):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'wsHandler := centrifuge.NewWebsocketHandler(node, centrifuge.WebsocketConfig{})\nhttp.Handle("/connection/websocket", auth(wsHandler))\n')),(0,i.kt)("p",null,"Another authentication way is a bit more generic \u2013 developers can authenticate connection based on custom token sent from a client inside first WebSocket/SockJS frame. This is called ",(0,i.kt)("inlineCode",{parentName:"p"},"connect")," frame in terms of Centrifuge protocol. Any string token can be set \u2013 this opens a way to use JWT, Paceto, and any other kind of authentication tokens. For example ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/centrifuge/tree/master/_examples/jwt_token"},"see an authenticaton with JWT"),"."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"BTW it's also possible to pass any information from client side with a first connect message from client to server and return custom information about server state to a client. This is out of post scope though.")),(0,i.kt)("p",null,"Nothing prevents you to ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/centrifuge/tree/master/_examples/chat_oauth2"},"integrate Centrifuge with OAuth2")," or another framework session mechanism \u2013 ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/centrifuge/tree/master/_examples/chat_oauth2"},"like Gin for example"),"."),(0,i.kt)("h2",{id:"channel-subscriptions"},"Channel subscriptions"),(0,i.kt)("p",null,"As soon as a client connected and successfully authenticated it can subscribe to channels. Channel (room or topic in other systems) is a lightweight and ephemeral entity in Centrifuge. Channel can have different features (we will look at some channel features below). Channels created automatically as soon as the first subscriber joins and destroyed as soon as the last subscriber left."),(0,i.kt)("p",null,"The application can have many real-time features \u2013 even on one app screen. So sometimes client subscribes to several channels \u2013 each related to a specific real-time feature (for example one channel for chat updates, one channel likes notification stream, etc)."),(0,i.kt)("p",null,"Channel is just an ASCII string. A developer is responsible to find the best channel naming convention suitable for an application. Channel naming convention is an important aspect since in many cases developers want to authorize subscription to a channel on the server side \u2013 so only authorized users could listen to specific channel updates."),(0,i.kt)("p",null,"Let's look at a basic subscription example on the client-side:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"centrifuge.subscribe('example', function(msgCtx) {\n    console.log(msgCtx)\n})\n")),(0,i.kt)("p",null,"On the server-side, you need to define subscribe event handler. If subscribe event handler not set then the connection won't be able to subscribe to channels at all. Subscribe event handler is where a developer may check permissions of the current connection to read channel updates. Here is a basic example of subscribe event handler that simply allows subscriptions to channel ",(0,i.kt)("inlineCode",{parentName:"p"},"example")," for all authenticated connections and reject subscriptions to all other channels:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'node.OnConnect(func(client *centrifuge.Client) {\n    client.OnSubscribe(func(e centrifuge.SubscribeEvent, cb centrifuge.SubscribeCallback) {\n        if e.Channel != "example" {\n            cb(centrifuge.SubscribeReply{}, centrifuge.ErrorPermissionDenied)\n            return\n        }\n        cb(centrifuge.SubscribeReply{}, nil)\n    })\n})\n')),(0,i.kt)("p",null,"You may notice a callback style of reacting to connection related things. While not being very idiomatic for Go it's very practical actually. The reason why we use callback style inside client event handlers is that it gives a developer possibility to control operation concurrency (i.e. process sth in separate goroutines or goroutine pool) and still control the order of events. See ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/centrifuge/tree/master/_examples/concurrency"},"an example")," that demonstrates concurrency control in action."),(0,i.kt)("p",null,"Now if some event published to a channel:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// Here is how we can publish data to a channel.\nnode.Publish("example", []byte(`{"input": "hello"}`))\n')),(0,i.kt)("p",null,"\u2013 data will be delivered to a subscribed client, and message will be printed to Javascript console. PUB/SUB in its usual form."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Though Centrifuge protocol based on Protobuf schema in example above we published a JSON message into a channel. By default, we can only send JSON to connections since default protocol format is JSON. But we can switch to Protobuf-based binary protocol by connecting to ",(0,i.kt)("inlineCode",{parentName:"p"},"ws://localhost:8000/connection/websocket?format=protobuf")," endpoint \u2013 then it's possible to send binary data to clients.")),(0,i.kt)("h2",{id:"async-message-passing"},"Async message passing"),(0,i.kt)("p",null,"While Centrifuge mostly shines when you need channel semantics it's also possible to send any data to connection directly \u2013 to achieve bidirectional asynchronous communication, just what a native WebSocket provides."),(0,i.kt)("p",null,"To send a message to a server one can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"send")," method on the client-side:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'centrifuge.send({"input": "hello"});\n')),(0,i.kt)("p",null,"On the server-side data will be available inside a message handler:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'client.OnMessage(func(e centrifuge.MessageEvent) {\n    log.Printf("message from client: %s", e.Data)\n})\n')),(0,i.kt)("p",null,"And vice-versa, to send data to a client use ",(0,i.kt)("inlineCode",{parentName:"p"},"Send")," method of ",(0,i.kt)("inlineCode",{parentName:"p"},"centrifuge.Client"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'client.Send([]byte(`{"input": "hello"}`))\n')),(0,i.kt)("p",null,"To listen to it on the client-side:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"centrifuge.on('message', function(data) {\n    console.log(data);\n});\n")),(0,i.kt)("h2",{id:"rpc"},"RPC"),(0,i.kt)("p",null,"RPC is a primitive for sending a request from a client to a server and waiting for a response (in this case all communication still happens via asynchronous message passing internally, but Centrifuge takes care of matching response data to request previously sent)."),(0,i.kt)("p",null,"On client side it's as simple as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const resp = await centrifuge.namedRPC('my_method', {});\n")),(0,i.kt)("p",null,"On server side RPC event handler should be set to make calls available:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'client.OnRPC(func(e centrifuge.RPCEvent, cb centrifuge.RPCCallback) {\n    if e.Method == "my_method" {\n        cb(centrifuge.RPCReply{Data: []byte(`{"result": "42"}`)}, nil)\n        return\n    }\n    cb(centrifuge.RPCReply{}, centrifuge.ErrorMethodNotFound)\n})\n')),(0,i.kt)("p",null,"Note, that it's possible to pass the name of RPC and depending on it and custom request params return different results to a client \u2013 just like a regular HTTP request but over asynchronous WebSocket (or SockJS) connection."),(0,i.kt)("h2",{id:"server-side-subscriptions"},"Server-side subscriptions"),(0,i.kt)("p",null,"In many cases, a client is a source of knowledge which channels it wants to subscribe to on a specific application screen. But sometimes you want to control subscriptions to channels on a server-side. This is also possible in Centrifuge."),(0,i.kt)("p",null,"It's possible to provide a slice of channels to subscribe connection to at the moment of connection establishment phase:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'node.OnConnecting(func(ctx context.Context, e centrifuge.ConnectEvent) (centrifuge.ConnectReply, error) {\n    return centrifuge.ConnectReply{\n        Subscriptions: map[string]centrifuge.SubscribeOptions{\n            "example": {},\n        },\n    }, nil\n})\n')),(0,i.kt)("p",null,"Note, that ",(0,i.kt)("inlineCode",{parentName:"p"},"OnConnecting")," does not follow callback-style \u2013 this is because it can only happen once at the start of each connection \u2013 so there is no need to control operation concurrency."),(0,i.kt)("p",null,"In this case on the client-side you will have access to messages published to channels by listening to ",(0,i.kt)("inlineCode",{parentName:"p"},"on('publish')")," event:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"centrifuge.on('publish', function(msgCtx) {\n    console.log(msgCtx);\n});\n")),(0,i.kt)("p",null,"Also, ",(0,i.kt)("inlineCode",{parentName:"p"},"centrifuge.Client")," has ",(0,i.kt)("inlineCode",{parentName:"p"},"Subscribe")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Unsubscribe")," methods so it's possible to subscribe/unsubscribe client to/from channel somewhere in the middle of its long WebSocket session."),(0,i.kt)("h2",{id:"windowed-history-in-channel"},"Windowed history in channel"),(0,i.kt)("p",null,"Every time a message published to a channel it's possible to provide custom history options. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'node.Publish(\n    "example",\n    []byte(`{"input": "hello"}`),\n    centrifuge.WithHistory(300, time.Minute),\n)\n')),(0,i.kt)("p",null,"In this case, Centrifuge will maintain a windowed Publication cache for a channel - or in other words, maintain a publication stream. This stream will have time retention (one minute in the example above) and the maximum size will be limited to the value provided during Publish (300 in the example above)."),(0,i.kt)("p",null,"Every message inside a history stream has an incremental ",(0,i.kt)("inlineCode",{parentName:"p"},"offset")," field. Also, a stream has a field called ",(0,i.kt)("inlineCode",{parentName:"p"},"epoch")," \u2013 this is a unique identifier of stream generation - thus client will have a possibility to distinguish situations where a stream is completely removed and there is no guarantee that no messages have been lost in between even if offset looks fine."),(0,i.kt)("p",null,"Client protocol provides a possibility to paginate over a stream from a certain position with a limit:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const streamPosition = {'offset': 0, epoch: 'xyz'} \nresp = await sub.history({since: streamPosition, limit: 10});\n")),(0,i.kt)("p",null,"Iteration over history stream is a new feature which is just merged into Centrifuge master branch and can only be used from Javascript client at the moment."),(0,i.kt)("p",null,"Also, Centrifuge has an automatic message recovery feature. Automatic recovery is very useful in scenarios when tons of persistent connections start reconnecting at once. I already described why this is useful in one of my previous posts about Websocket scalability. In short \u2013 since WebSocket connections are stateful then at the moment of mass reconnect they can create a very big spike in load on your main application database. Such mass reconnects are a usual thing in practice - for example when you reload your load balancers or re-deploying the Websocket server (new code version)."),(0,i.kt)("p",null,"Of course, recovery can also be useful for regular short network disconnects - when a user travels in the subway for example. But you always need a way to load an actual state from the main application database in case of an unsuccessful recovery."),(0,i.kt)("p",null,"To enable automatic recovery you can provide the ",(0,i.kt)("inlineCode",{parentName:"p"},"Recover")," flag in subscribe options:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"client.OnSubscribe(func(e centrifuge.SubscribeEvent, cb centrifuge.SubscribeCallback) {\n    cb(centrifuge.SubscribeReply{\n        Options: centrifuge.SubscribeOptions{\n            Recover:   true,\n        },\n    }, nil)\n})\n")),(0,i.kt)("p",null,"Obviously, recovery will work only for channels where history stream maintained. The limitation in recovery is that all missed publications sent to client in one protocol frame \u2013 pagination is not supported during recovery process. This means that recovery is mostly effective for not too long offline time without tons of missed messages."),(0,i.kt)("h2",{id:"online-presence-and-presence-stats"},"Online presence and presence stats"),(0,i.kt)("p",null,"Another cool thing Centrifuge exposes to developers is online presence information for channels. Presence information contains a list of active channel subscribers. This is useful to show the online status of players in a game for example."),(0,i.kt)("p",null,"Also, it's possible to turn on Join/Leave message feature inside channels: so each time connection subscribes to a channel all channel subscribers receive a Join message with client information (client ID, user ID). As soon as the client unsubscribes Leave message is sent to remaining channel subscribers with information who left a channel."),(0,i.kt)("p",null,"Here is how to enable both online presence and join/leave features for a subscription to channel:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"client.OnSubscribe(func(e centrifuge.SubscribeEvent, cb centrifuge.SubscribeCallback) {\n    cb(centrifuge.SubscribeReply{\n        Options: centrifuge.SubscribeOptions{\n            Presence:   true,\n            JoinLeave:  true,\n        },\n    }, nil)\n})\n")),(0,i.kt)("p",null,"On a client-side then it's possible to call for the presence and setting event handler for join/leave messages. "),(0,i.kt)("p",null,"The important thing to be aware of when using Join/Leave messages is that this feature can dramatically increase CPU utilization and overall traffic in channels with a big number of active subscribers \u2013 since on every client connect/disconnect event such Join or Leave message must be sent to all subscribers. The advice here \u2013 avoid using Join/Leave messages or be ready to scale (Join/Leave messages scale well when adding more Centrifuge Nodes \u2013 more about scalability below)."),(0,i.kt)("p",null,"One more thing to remember is that online presence information can also be pretty expensive to request in channels with many active subscribers \u2013 since it returns information about all connections \u2013 thus payload in response can be large. To help a bit with this situation Centrifuge has a presence stats client API method. Presence stats only contain two counters: the number of active connections in the channel and amount of unique users in the channel."),(0,i.kt)("p",null,"If you still need to somehow process online presence in rooms with a massive number of active subscribers \u2013 then I think you better do it in near real-time - for example with fast OLAP like ",(0,i.kt)("a",{parentName:"p",href:"https://clickhouse.tech/"},"ClickHouse"),"."),(0,i.kt)("h2",{id:"scalability-aspects"},"Scalability aspects"),(0,i.kt)("p",null,"To be fair it's not too hard to implement most of the features above inside one in-memory process. Yes, it takes time, but the code is mostly straightforward. When it comes to scalability things tend to be a bit harder."),(0,i.kt)("p",null,"Centrifuge designed with the idea in mind that one machine is not enough to handle all application WebSocket connections. Connections should scale over application backend instances, and it should be simple to add more application nodes when the amount of users (connections) grows."),(0,i.kt)("p",null,"Centrifuge abstracts scalability over the ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," instance and two interfaces: ",(0,i.kt)("inlineCode",{parentName:"p"},"Broker")," interface and ",(0,i.kt)("inlineCode",{parentName:"p"},"PresenceManager")," interface."),(0,i.kt)("p",null,"A broker is responsible for PUB/SUB and streaming semantics:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type Broker interface {\n    Run(BrokerEventHandler) error\n    Subscribe(ch string) error\n    Unsubscribe(ch string) error\n    Publish(ch string, data []byte, opts PublishOptions) (StreamPosition, error)\n    PublishJoin(ch string, info *ClientInfo) error\n    PublishLeave(ch string, info *ClientInfo) error\n    PublishControl(data []byte, nodeID string) error\n    History(ch string, filter HistoryFilter) ([]*Publication, StreamPosition, error)\n    RemoveHistory(ch string) error\n}\n")),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/centrifuge/blob/v0.14.2/engine.go#L98"},"full version with comments")," in source code."),(0,i.kt)("p",null,"Every Centrifuge Node subscribes to channels via a broker. This provides a possibility to scale connections over many node instances \u2013 published messages will flow only to nodes with active channel subscribers."),(0,i.kt)("p",null,"It's and important thing to combine PUB/SUB with history inside a Broker implementation to achieve an atomicity of saving message into history stream and publishing it to PUB/SUB with generated offset."),(0,i.kt)("p",null,"PresenceManager is responsible for online presence information management:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type PresenceManager interface {\n    Presence(ch string) (map[string]*ClientInfo, error)\n    PresenceStats(ch string) (PresenceStats, error)\n    AddPresence(ch string, clientID string, info *ClientInfo, expire time.Duration) error\n    RemovePresence(ch string, clientID string) error\n}\n")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/centrifuge/blob/v0.14.2/engine.go#L150"},"Full code with comments"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Broker")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"PresenceManager")," together form an ",(0,i.kt)("inlineCode",{parentName:"p"},"Engine")," interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type Engine interface {\n    Broker\n    PresenceManager\n}\n")),(0,i.kt)("p",null,"By default, Centrifuge uses ",(0,i.kt)("inlineCode",{parentName:"p"},"MemoryEngine")," that does not use any external services but limits developers to using only one Centrifuge Node (i.e. one server instance). Memory Engine is fast and can be suitable for some scenarios - even in production (with configured backup instance) \u2013 but as soon as the number of connections grows \u2013 you may need to load balance connections to different server instances. Here comes the Redis Engine."),(0,i.kt)("p",null,"Redis Engine utilizes Redis for Broker and PresenceManager parts."),(0,i.kt)("p",null,"History cache saved to Redis STREAM or Redis LIST data structures. For presence, Centrifuge uses a combination of HASH and ZSET structures."),(0,i.kt)("p",null,"Centrifuge tries to fully utilize the connection between Node and Redis by using pipelining where possible and smart batching technique. All operations done in a single RTT with the help of Lua scripts loaded automatically to Redis on engine start."),(0,i.kt)("p",null,"Redis is pretty fast and will allow your app to scale to some limits. When Redis starts being a bottleneck it's possible to shard data over different Redis instances. Client-side consistent sharding is built-in in Centrifuge and allows scaling further."),(0,i.kt)("p",null,"It's also possible to achieve Redis's high availability with built-in Sentinel support. Redis Cluster supported too. So Redis Engine covers many options to communicate with Redis deployed in different ways."),(0,i.kt)("p",null,"At Avito we served about 800k active connections in the messenger app with ease using a slightly adapted Centrifuge Redis Engine, so an approach proved to be working for rather big applications. We will look at some more concrete numbers below in the performance section."),(0,i.kt)("p",null,"Both ",(0,i.kt)("inlineCode",{parentName:"p"},"Broker")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"PresenceManager")," are pluggable, so it's possible to replace them with alternative implementations. Examples show ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/centrifuge/tree/master/_examples/custom_broker_nats"},"how to use Nats server")," for at most once only PUB/SUB together with Centrifuge. Also, we have ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/centrifuge/tree/master/_examples/custom_engine_tarantool"},"an example of full-featured Engine for Tarantool database")," \u2013 Tarantool Engine shows even better throughput for history and presence operations than Redis-based Engine (up to 10x for some ops)."),(0,i.kt)("h2",{id:"order-and-delivery-properties"},"Order and delivery properties"),(0,i.kt)("p",null,"Since Centrifuge is a messaging system I also want to describe its order and message delivery guarantees."),(0,i.kt)("p",null,"Message ordering in channels supported. As soon as you publish messages into channels one after another of course."),(0,i.kt)("p",null,"Message delivery model is at most once by default. This is mostly comes from PUB/SUB model \u2013 message can be dropped on Centrifuge level if subscriber is offline or simply on broker level \u2013 since Redis PUB/SUB also works with at most once guarantee."),(0,i.kt)("p",null,"Though if you maintain history stream inside a channel then things become a bit different. In this case you can tell Centrifuge to check client position inside stream. Since every publication has a unique incremental offset Centrifuge can track that client has correct offset inside a channel stream. If Centrifuge detects any missed messages it disconnects a client with special code \u2013 thus make it reconnect and recover messages from history stream. Since a message first saved to history stream and then published to PUB/SUB inside broker these mechanisms allow achieving at least once message delivery guarantee."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/PLb9xS5.jpg",alt:"What happens on publish"})),(0,i.kt)("p",null,"Even if stream completely expired or dropped from broker memory Centrifuge will give a client a tip that messages could be lost \u2013 so client has a chance to restore state from a main application database."),(0,i.kt)("h2",{id:"ecosystem"},"Ecosystem"),(0,i.kt)("p",null,"Here I want to be fair with my readers \u2013 Centrifuge is not ideal. This is a project maintained mostly by one person at the moment with all consequences. This hits an ecosystem a lot, can make some design choices opinionated or non-optimal."),(0,i.kt)("p",null,"I mentioned in the first post that Centrifuge built on top of the custom protocol. The protocol is based on a strict Protobuf schema, works with JSON and binary data transfer, supports many features. But \u2013 this means that to connect to the Centrifuge-based server developers have to use custom connectors that can speak with Centrifuge over its custom protocol."),(0,i.kt)("p",null,"The difficulty here is that protocol is asynchronous. Asynchronous protocols are harder to implement than synchronous ones. Multiplexing frames allows achieving good performance and fully utilize a single connection \u2013 but it hurts simplicity."),(0,i.kt)("p",null,"At this moment Centrifuge has client connectors for:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/centrifugal/centrifuge-js"},"centrifuge-js")," - Javascript client for a browser, NodeJS and React Native"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/centrifugal/centrifuge-go"},"centrifuge-go")," - for Go language"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/centrifugal/centrifuge-mobile"},"centrifuge-mobile")," - for mobile development based on centrifuge-go and ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/golang/mobile"},"gomobile")," project"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/centrifugal/centrifuge-swift"},"centrifuge-swift")," - for iOS native development"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/centrifugal/centrifuge-java"},"centrifuge-java")," - for Android native development and general Java"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/centrifugal/centrifuge-dart"},"centrifuge-dart")," - for Dart and Flutter")),(0,i.kt)("p",null,"Not all clients support all protocol features. Another drawback is that all clients do not have a persistent maintainer \u2013 I mostly maintain everything myself. Connectors can have non-idiomatic and pretty dumb code since I had no previous experience with mobile development, they lack proper tests and documentation. This is unfortunate."),(0,i.kt)("p",null,"The good thing is that all connectors feel very similar, I am quickly releasing new versions when someone sends a pull request with improvements or bug fixes. So all connectors are alive."),(0,i.kt)("p",null,"I maintain a feature matrix in connectors to let users understand what's supported. Actually feature support is pretty nice throughout all these connectors - there are only several things missing and not so much work required to make all connectors full-featured. But I really need help here."),(0,i.kt)("p",null,"It will be a big mistake to not mention Centrifugo as a big plus for Centrifuge library ecosystem. Centrifugo is a server deployed in many projects throughout the world. Many features of Centrifuge library and its connectors have already been tested by Centrifugo users."),(0,i.kt)("p",null,"One more thing to mention is that Centrifuge does not have v1 release. It still evolves \u2013 I believe that the most dramatic changes have already been made and backward compatibility issues will be minimal in the next releases \u2013 but can't say for sure."),(0,i.kt)("h2",{id:"performance"},"Performance"),(0,i.kt)("p",null,"I made a test stand in Kubernetes with one million connections."),(0,i.kt)("p",null,"I can't call this a proper benchmark \u2013 since in a benchmark your main goal is to destroy a system, in my test I just achieved some reasonable numbers on limited hardware. These numbers should give a good insight into a possible throughput, latency, and estimate hardware requirements (at least approximately)."),(0,i.kt)("p",null,"Connections landed on different server pods, 5 Redis instances have been used to scale connections between pods."),(0,i.kt)("p",null,"The detailed test stand description ",(0,i.kt)("a",{parentName:"p",href:"https://centrifugal.github.io/centrifugo/misc/benchmark/"},"can be found in Centrifugo documentation"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Benchmark",src:n(6842).Z,width:"1860",height:"916"})),(0,i.kt)("p",null,"Some quick conclusions are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"One connection costs about 30kb of RAM"),(0,i.kt)("li",{parentName:"ul"},"Redis broker CPU utilization increases linearly with more messages traveling around"),(0,i.kt)("li",{parentName:"ul"},"1 million connections with 500k ",(0,i.kt)("strong",{parentName:"li"},"delivered")," messages per second with 200ms delivery latency in 99 percentile can be served with hardware amount equal to one modern physical server machine. The possible amount of messages can vary a lot depending on the number of channel subscribers though.")),(0,i.kt)("h2",{id:"limitations"},"Limitations"),(0,i.kt)("p",null,"Centrifuge does not allow subscribing on the same channel twice inside a single connection. It's not simple to add due to design decisions made \u2013 though there was no single user report about this in seven years of Centrifugo/Centrifuge history."),(0,i.kt)("p",null,"Centrifuge does not support wildcard subscriptions. Not only because I never needed this myself but also due to some design choices made \u2013 so be aware of this."),(0,i.kt)("p",null,"SockJS fallback does not support binary data - only JSON. If you want to use binary in your application then you can only use WebSocket with Centrifuge - there is no built-in fallback transport in this case."),(0,i.kt)("p",null,"SockJS also requires sticky session support from your load balancer to emulate a stateful bidirectional connection with its HTTP fallback transports. Ideally, Centrifuge will go away from SockJS at some point, maybe when WebTransport becomes mature so users will have a choice between WebTransport or WebSocket."),(0,i.kt)("p",null,"Websocket ",(0,i.kt)("inlineCode",{parentName:"p"},"permessage-deflate")," compression supported (thanks to Gorilla WebSocket), but it can be pretty expensive in terms of CPU utilization and memory usage \u2013 the overhead depends on usage pattern, it's pretty hard to estimate in numbers."),(0,i.kt)("p",null,"As said above you cannot only rely on Centrifuge for state recovery \u2013 it's still required to have a way to fully load application state from the main database."),(0,i.kt)("p",null,"Also, I am not very happy with current error and disconnect handling throughout the connector ecosystem \u2013 this can be improved though, and I have some ideas for the future."),(0,i.kt)("h2",{id:"examples"},"Examples"),(0,i.kt)("p",null,"I am adding examples to ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/centrifuge/tree/master/_examples"},"_examples")," folder of Centrifuge repo. These examples completely cover Centrifuge API - including things not mentioned here."),(0,i.kt)("p",null,"Check out the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/centrifuge#tips-and-tricks"},"tips & tricks")," section of README \u2013 it contains some additional insights about an implementation."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"I think ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/centrifuge"},"Centrifuge")," could be a nice alternative to ",(0,i.kt)("a",{parentName:"p",href:"https://socket.io"},"socket.io")," - with a better performance, main server implementation in Go language, and even more builtin features to build real-time apps."),(0,i.kt)("p",null,"Centrifuge ecosystem definitely needs more work, especially in client connectors area, tutorials, community, stabilizing API, etc."),(0,i.kt)("p",null,"Centrifuge fits pretty well proprietary application development where time matters and deadlines are close, so developers tend to choose a ready solution instead of writing their own. I believe Centrifuge can be a great time saver here."),(0,i.kt)("p",null,"For Centrifugo server users Centrifuge package provides a way to write a more flexible server code adapted for business requirements but still use the same real-time core and have the same protocol features."))}p.isMDXComponent=!0},6842:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/benchmark-b670972866abdc8936d2aef84333dd0c.gif"}}]);